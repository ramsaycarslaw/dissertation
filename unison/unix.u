{-
    BasicIO
    =========
-}

unique ability BasicIO
    where
        echo: Text -> {BasicIO } ()

basicIO : Request {BasicIO} x ->{IO, Exception} ()
basicIO result =
    match result with
        { echo text -> resume } -> putText stdOut text; handle resume () with basicIO
        { result } -> ()


{-
    Status
    =========
-}

-- The unix exit command that allows you to exit with error code
unique ability Status
       where
            exit: Nat -> ()

-- handles the exit command which just returns an integer
exitHandler : Request {g, Status} x -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> v

{-
Userspace
==========

This handles the hard coded users and their environments.
It allows for whoami and su commands to be run.

-}

-- The users (hard coded)
unique type User = Alice | Bob | Root
structural type Environment = Environment User

-- Each user has a unique environment
environments : List (User, Environment)
environments = [(Alice, Environment Alice),
                (Bob, Environment Bob),
                (Root, Environment Root)]

unique ability Session
    where
        su: User -> {Session } Environment
        whoami: {Session } Text

-- Helper function because unison cannot infer equity on custom types
userEquals: User -> User -> Boolean
userEquals user1 user2 =
    match user1 with
        Alice -> match user2 with
            Alice -> true
            _ -> false
        Bob -> match user2 with
            Bob -> true
            _ -> false
        Root -> match user2 with
            Root -> true
            _ -> false

-- returns the environment of a user, usually from the hard coded environments
envOf: (User, [(User, Environment)]) -> Environment
envOf t = match t with
    (user, envStore) ->
        match envStore with
            [] -> Environment user -- TODO add failure here
            (user', env) +: rest ->
                if userEquals user user' then env
                else envOf (user, rest)

sessionManager : Environment -> Request {Session} a -> a
sessionManager initial request =
    match request with
          { su user -> resume }
            -> newEnv = envOf (user, environments)
               -- We fecth the correct environment and then resume with it
               handle resume newEnv with sessionManager newEnv
          { whoami -> resume}
            -> match initial with
                -- this could probbaly be made generic with some User -> Text function
                Environment Alice -> handle resume "alice" with sessionManager initial
                Environment Bob -> handle resume "bob" with sessionManager initial
                Environment Root -> handle resume "root" with sessionManager initial
          { result } -> result

-- shorthand
initialEnv : Environment
initialEnv = envOf (Root, environments)

{-
      Time Sharing
   ==================
-}

unique ability Interrupt
    where
        interrupt: {Interrupt } ()


-- unique type PState a = Done a | Paused (Unit ->{Interrupt} a)
unique type PState a e = Done a | Paused ('{e} PState a e)


--reifyProcess : Request {Interrupt} a -> PState a e
--reifyProcess request =
--    match request with
--        { interrupt -> resume } -> ( handle resume with reifyProcess )
--        { result } -> Done result

reifyProcess : Request {g, Interrupt} (PState a {g, Interrupt}) -> PState a {g, Interrupt}
reifyProcess request =
    match request with
        { interrupt -> resume } -> Paused resume
        { result } -> result

unique ability TimeSharing
    where
        fork: {TimeSharing } Boolean

-- handler for time sharing ability
nondet : Request {TimeSharing} a -> [a]
nondet request =
    match request with
        { fork -> resume } -> (handle resume true with nondet) lib.base.data.List.++ (handle resume false with nondet)
        { result } -> [result]

scheduler : [PState a {TimeSharing, Interrupt}] -> [a]
scheduler processes =
    match processes with
        [] -> []
        Done result +: rest -> result +: scheduler rest
        Paused resume +: rest -> scheduler (rest ++ handle (handle resume () with reifyProcess) with nondet)

interruptIO : Request {BasicIO} x ->{IO, Exception, Interrupt} ()
interruptIO result =
    match result with
        { echo text -> resume } -> interrupt; putText stdOut text; handle resume () with basicIO
        { result } -> ()


--scheduler : [PState a] -> [a]
--scheduler processes =
--    match processes with
--        [] -> []
--        Done result +: rest -> result +: scheduler rest
--        Paused resume +: rest -> scheduler (rest) ++ handle resume () with nondet


{-
  Serial File System
  ==================
-}

unique ability State a
       where
            put: a -> ()
            get: () -> a

runState pair =
         match pair with
               (state, request) ->
                       match request with
                             { res } -> (state, res)

unique type DirectoryT = Directory (Text, Nat)
unique type DataRegionT = DataRegion (Nat, Text)
unique type INodeT = INode Nat Nat
unique type IListT = IList (Nat, INodeT)
unique type FileSystemT = FileSystem (List DirectoryT) (List IListT) (List DataRegionT) Nat Nat


initialINode : INodeT
initialINode = INode 0 0

initialDirectory : DirectoryT
initialDirectory = (Directory ("stdout", 0))

initialDataRegion : DataRegionT
initialDataRegion = DataRegion (0, "")

initialIList : IListT
initialIList = IList (0, initialINode)

initialFileSystem : FileSystemT
initialFileSystem = FileSystem [initialDirectory] [initialIList] [initialDataRegion] 0 0

unique ability FileRW
    where
        -- Read INode number -> File
        read: Nat -> {FileRW } Text
        -- Write INode number, Text -> ()
        write: (Nat, Text) -> {FileRW } ()


lookupINode : Nat -> [IListT] -> Either INodeT ()
lookupINode i ilists =
    match ilists with
        [] -> Right ()
        (IList (i', inode)) +: rest ->
            if i == i' then Left inode
            else lookupINode i rest

modifyINode : Nat -> INodeT -> [IListT] -> [IListT]
modifyINode i inode ilists =
    match ilists with
        [] -> []
        (IList (i', inode')) +: rest ->
            if i == i' then (IList (i, inode)) +: rest
            else (IList (i', inode')) +: modifyINode i inode rest

lookupDataRegion : Nat -> [DataRegionT] -> Either Text ()
lookupDataRegion i dataRegions =
    match dataRegions with
        [] -> Right ()
        (DataRegion (i', text)) +: rest ->
            if i == i' then Left text
            else lookupDataRegion i rest

modifyDataRegion : Nat -> Text -> [DataRegionT] -> [DataRegionT]
modifyDataRegion i text dataRegions =
    match dataRegions with
        [] -> []
        (DataRegion (i', text')) +: rest ->
            if i == i' then (DataRegion (i, (text' ++ text))) +: rest
            else (DataRegion (i', text')) +: modifyDataRegion i text rest

-- fread, implementation of system read
fread : Nat -> FileSystemT -> Either Text ()
fread i fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            match lookupDataRegion dataRegion dataRegions with
                                Left text -> Left text
                                Right () -> Right ()
                Right () -> Right ()

-- fwrite, writes to the file system at the given inode with the given text
fwrite : Nat -> Text -> FileSystemT -> FileSystemT
fwrite i text fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            FileSystem directories (modifyINode i (INode i dataRegion) ilists) (modifyDataRegion dataRegion text dataRegions) 0 0
                Right () -> fs

--fileRW : Request {FileRW} a -> FileSystemT
--fileRW result =
--    match result with
--        { read i -> resume } -> fread i (handle resume text with fileRW)
--        { write (i, text) -> resume } -> fwrite i text (handle resume () with fileRW)
--        { result } -> result


{-
    Tests
============
-}

-- Test exiting
testProgram0 _ = exit 42
--> handle !testProgram0 with exitHandler

testProgram1 _ =
    whoami
--> handle !testProgram1 with whoamiHandler

testProgram2 _ =
    handle whoami with sessionManager (handle su Alice with sessionManager initialEnv)
--> handle !testProgram2 with sessionManager initialEnv

proc1 _ = handle [echo "Hello, ", echo "World!"] with basicIO
proc2 _ = handle [echo "Goodbye, ", echo "Code!"] with basicIO

testProgram3 _ =
    handle whoami with sessionManager (handle su Bob with sessionManager initialEnv)

testProgram4 _ =
    if fork then
        [handle whoami with sessionManager (handle su Bob with sessionManager initialEnv)]
     else
        [handle whoami with sessionManager (handle su Alice with sessionManager initialEnv)]
--> handle !testProgram4 with nondet

ritchie _ = echo "UNIX is basically\n"; echo "a simple operating system\n"; echo "but you have to be a genius to understand the simplicity\n"
hamlet _ = echo "To be, or not to be,\n"; echo "that is the question:\n"; echo "Wether 'tis nobler in the mind to suffer\n";

testProgram5 _ =
    handle (handle (if fork then [!ritchie] else [!hamlet]) with basicIO) with nondet

testProgram6 _ =
    handle (if fork then [ritchie] else [hamlet]) with basicIO