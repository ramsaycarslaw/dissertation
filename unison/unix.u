{-
    BasicIO
    =========
-}

unique ability BasicIO
    where
        echo: Text -> ()

basicIO : Request {BasicIO} x ->{IO, Exception} ()
basicIO result =
    match result with
        { echo text -> resume } -> putText stdOut text; handle resume () with basicIO
        { result } -> ()


{-
    Status
    =========
-}

-- The unix exit command that allows you to exit with error code
unique ability Status
       where
            exit: Nat -> ()

-- handles the exit command which just returns an integer
exitHandler : Request {g, Status} x -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> v

{-
Userspace
==========

This handles the hard coded users and their environments.
It allows for whoami and su commands to be run.

-}

-- The users (hard coded)
unique type User = Username Text

unique ability Session
    where
        su: Text -> ()
        ask: Text -> Text
        export: Text -> Text -> ()
        adduser: Text -> ()

whoami: '{Session} Text
whoami _ = ask "USER"

env: User -> Request {Session} a ->{State [(User, [(Text, Text)])]} a
env user request = 
    match request with
        {result} -> result

        { ask var -> resume } -> 
           let st = get ()
               envs = lookupEnvs user st
               val = lookupEnvVar var envs
               handle resume val with env user

        {su user' -> resume} -> 
            if userExists (Username user') (get ()) then
                handle resume () with env (Username user')
            else 
                handle resume () with env user   -- fail

        {export var val -> resume} -> 
            let st = get ()
                envs = lookupEnvs user st
                envs' = modifyEnvVar var val envs
                put (modifyEnvs user envs' st) 
                handle resume () with env user

        {adduser user' -> resume} ->
            if userToText user == "root" then
                let st = get ()
                    newuser = (Username user')
                    newvars = [("USER", user')]
                    newenv = modifyEnvs newuser newvars st
                    if (userExists newuser st) then
                        put newenv
                        handle resume () with env newuser
                    else 
                        handle resume () with env user  -- fail
            else 
                handle resume () with env user   -- fail

lookupEnvVar: Text -> [(Text, Text)] -> Text
lookupEnvVar var env =
    match env with
        [] -> ""
        (var', val) +: rest ->
            if var == var' then val
            else lookupEnvVar var rest

modifyEnvVar: Text -> Text -> [(Text, Text)] -> [(Text, Text)]
modifyEnvVar var val env =
    match env with
        [] -> [(var, val)]
        (var', val') +: rest ->
            if var == var' then (var, val) +: rest
            else (var', val') +: modifyEnvVar var val rest

lookupEnvs: User -> [(User, [(Text, Text)])] -> [(Text, Text)]
lookupEnvs user envs =
    match envs with
        [] -> []
        (user', env) +: rest ->
            if userToText user == userToText user' then env
            else lookupEnvs user rest

modifyEnvs: User -> [(Text, Text)] -> [(User, [(Text, Text)])] -> [(User, [(Text, Text)])]
modifyEnvs user env envs =
    match envs with
        [] -> [(user, env)]
        (user', env') +: rest ->
            if userToText user == userToText user' then (user, env) +: rest
            else (user', env') +: modifyEnvs user env rest

userExists: User -> [(User, [(Text, Text)])] -> Boolean
userExists user envs =
    match envs with
        [] -> false
        (user', env) +: rest ->
            if userToText user == userToText user' then true
            else userExists user rest

userToText: User -> Text
userToText user = 
    let (Username username) = user
        username

initialUserspace : [(User, [(Text, Text)])]
initialUserspace = [(Username "root", [("USER", "root")] )]

{-
      Time Sharing
   ==================
-}

unique ability Interrupt
    where
        interrupt: {Interrupt } ()


unique type PState a e = Done a | Paused ('{e} PState a e)

interruptWrite : Request {e, BasicIO} x ->{e, Interrupt, BasicIO} ()
interruptWrite result =
    match result with
        { echo text -> resume } -> 
            interrupt
            echo text 
            handle resume () with interruptWrite
        { result } -> ()

reifyProcess : Request {Interrupt, e} a -> PState a e
reifyProcess request =
    match request with
        { interrupt -> resume } -> Paused (_ -> handle !resume with reifyProcess )
        { result } -> Done result

unique ability TimeSharing
    where
        fork: {TimeSharing } Boolean

-- handler for time sharing ability
nondet : Request {TimeSharing} a -> [a]
nondet request =
    match request with
        { fork -> resume } -> (handle resume true with nondet) lib.base.data.List.++ (handle resume false with nondet)
        { result } -> [result]

sched : [PState a {e, TimeSharing}] -> [a] ->{e} [a]
sched ps done = 
    match ps with
        [] -> done
        (Done res) +: ps' -> sched ps' (res lib.base.data.List.+: done)
        (Paused m) +: ps' -> sched (ps' lib.base.data.List.++ (handle !m with nondet)) done

timeshare : '{g, Interrupt, TimeSharing} o ->{g} [o]
timeshare m = sched [Paused (_ -> handle !m with reifyProcess)] []

{-
  Serial File System
  ==================
-}

unique ability State a
       where
            put: a -> ()
            get: () -> a

runState : a -> Request {State a} b -> b
runState v request =
    match request with
        { put v' -> resume } -> handle resume () with runState v'
        { get () -> resume } -> handle resume v with runState v
        { result } -> result

unique type DirectoryT = Directory (Text, Nat)
unique type DataRegionT = DataRegion (Nat, Text)
unique type INodeT = INode Nat Nat
unique type IListT = IList (Nat, INodeT)
unique type FileSystemT = FileSystem (List DirectoryT) (List IListT) (List DataRegionT) Nat Nat


initialINode : INodeT
initialINode = INode 0 0

initialDirectory : DirectoryT
initialDirectory = (Directory ("stdout", 0))

testDirectory : DirectoryT
testDirectory = (Directory ("test.txt", 1))

initialDataRegion : DataRegionT
initialDataRegion = DataRegion (0, "")

testDataRegion : DataRegionT
testDataRegion = DataRegion (1, "Hello, World!\n")

initialIList : IListT
initialIList = IList (0, initialINode)

testIList : IListT
testIList = IList (1, initialINode)

initialFileSystem : FileSystemT
initialFileSystem = FileSystem [initialDirectory, testDirectory] [initialIList, testIList] [initialDataRegion, testDataRegion] 0 0

lookupINode : Nat -> [IListT] -> Either INodeT ()
lookupINode i ilists =
    match ilists with
        [] -> Right ()
        (IList (i', inode)) +: rest ->
            if i == i' then Left inode
            else lookupINode i rest

lookupFName : Text -> [DirectoryT] -> Either Nat ()
lookupFName name directories =
    match directories with
        [] -> Right ()
        (Directory (name', i)) +: rest ->
            if name == name' then Left i
            else lookupFName name rest

modifyINode : Nat -> INodeT -> [IListT] -> [IListT]
modifyINode i inode ilists =
    match ilists with
        [] -> []
        (IList (i', inode')) +: rest ->
            if i == i' then (IList (i, inode)) +: rest
            else (IList (i', inode')) +: modifyINode i inode rest

lookupDataRegion : Nat -> [DataRegionT] -> Either Text ()
lookupDataRegion i dataRegions =
    match dataRegions with
        [] -> Right ()
        (DataRegion (i', text)) +: rest ->
            if i == i' then Left text
            else lookupDataRegion i rest

modifyDataRegion : Nat -> Text -> [DataRegionT] -> [DataRegionT]
modifyDataRegion i text dataRegions =
    match dataRegions with
        [] -> []
        (DataRegion (i', text')) +: rest ->
            if i == i' then (DataRegion (i, (text' ++ text))) +: rest
            else (DataRegion (i', text')) +: modifyDataRegion i text rest

-- fread, implementation of system read
fread : Nat -> FileSystemT -> Either Text ()
fread i fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            match lookupDataRegion dataRegion dataRegions with
                                Left text -> Left text
                                Right () -> Right ()
                Right () -> Right ()

-- fwrite, writes to the file system at the given inode with the given text
fwrite : Nat -> Text -> FileSystemT -> FileSystemT
fwrite i text fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            FileSystem directories (modifyINode i (INode i dataRegion) ilists) (modifyDataRegion dataRegion text dataRegions) 0 0
                Right () -> fs

unique ability FileRW
         where
                read: Nat -> {FileRW } Text
                write: (Nat, Text) -> {FileRW } ()

fileRW : Request {FileRW} a ->{State FileSystemT} a
fileRW result =
    match result with
        { read i -> resume } ->
            let fs = get ()
                text = fread i fs
                match text with
                    Left text -> handle resume text with fileRW
                    Right () -> handle resume "" with fileRW   -- make this fail
        { write (i, text) -> resume } ->
            let fs = get ()
                fs' = fwrite i text fs
                put fs'
                handle resume () with fileRW
        { result } -> result


fileEcho: Request {BasicIO} a ->{State FileSystemT} a
fileEcho m = match m with 
    { echo text -> resume } -> 
        let fs = get ()
            put (fwrite 0 text fs)
            handle resume () with fileEcho
    { result } -> result


--echoWrite : Text ->{FileRW} ()
--echoWrite text = write (0, text)
--
--systemIO : Request {BasicIO} a ->{FileRW, State FileSystemT} a
--systemIO result =
--    match result with
--        { echo text -> resume } ->
--            handle write (0, text) with fileRW
--            handle resume () with systemIO
--        { result } -> result

fopen : Text -> FileSystemT -> Nat
fopen name fs = 
    match fs with
        FileSystem directories ilists dataRegions dnext inext ->
            match lookupFName name directories with
                Left i -> i
                Right () -> inext

has : Text -> [DirectoryT] -> Boolean
has name directories =
    match directories with
        [] -> false
        (Directory (name', i)) +: rest ->
            if name == name' then true
            else has name rest

fcreate : Text -> FileSystemT -> (Nat, FileSystemT)
fcreate name fs = 
    match fs with 
        FileSystem directories ilists dataRegions dnext inext ->
            -- file already exists, overwrite it
            if has name directories then 
                let ino = (fopen name fs)
                    inode = lookupINode ino ilists
                    match inode with
                        Left inode -> 
                            match inode with 
                                INode ino loc ->
                                    let dreg' = modifyDataRegion loc "" dataRegions
                                        (ino , FileSystem directories ilists dreg' dnext inext)
                        Right () -> (ino, fs) -- unreacable
            else 
                let inext' = inext + 1
                    dnext' = dnext + 1
                    inode = INode inext dnext
                    ilists' = (IList (inext, inode)) +: ilists
                    directories' = (Directory (name, inext)) +: directories
                    (inext, FileSystem directories' ilists' dataRegions dnext' inext')

unique ability FileCO
    where
        open: Text -> {FileCO } Nat
        close: Nat -> {FileCO } ()

fileCO : Request {FileCO} a ->{FileRW, State FileSystemT} a
fileCO result =
    match result with
        { open name -> resume } ->
            let fs = get ()
                (ino, fs') = fcreate name fs
                put fs'
                handle resume ino with fileCO
        { close i -> resume } ->
            let fs = get ()
                put fs
                handle resume () with fileCO
        { result } -> result

flink: Text -> Text -> FileSystemT -> FileSystemT
flink src dest fs =
    match fs with
        FileSystem directories ilists dataRegions dnext inext ->
            if has dest directories then
               fs -- error, file exists
            else
                let ino = lookupFName src directories
                    match ino with
                        Left ino ->
                            let directories' = (Directory (dest, ino)) +: directories
                                inode = lookupINode ino ilists
                                match inode with
                                    Left inode ->
                                        match inode with
                                            INode ino loc ->
                                                  let loc' = loc + 1
                                                      inode' = INode ino loc'
                                                      ilists' = modifyINode ino inode' ilists
                                                      FileSystem directories' ilists' dataRegions dnext inext
                                    Right () -> fs -- unreachable, we know the file exists
                        Right () -> fs -- no such file src

removeINode : Nat -> [IListT] -> [IListT]
removeINode i ilists =
    match ilists with
        [] -> []
        (IList (i', inode)) +: rest ->
            if i == i' then rest
            else (IList (i', inode)) +: removeINode i rest

removeDataRegion : Nat -> [DataRegionT] -> [DataRegionT]
removeDataRegion i dataRegions =
    match dataRegions with
        [] -> []
        (DataRegion (i', text)) +: rest ->
            if i == i' then rest
            else (DataRegion (i', text)) +: removeDataRegion i rest

removeDirectory : Text -> [DirectoryT] -> [DirectoryT]
removeDirectory name directories =
    match directories with
        [] -> []
        (Directory (name', i)) +: rest ->
            if name == name' then rest
            else (Directory (name', i)) +: removeDirectory name rest

funlink: Text -> FileSystemT -> FileSystemT
funlink name fs =
    match fs with
        FileSystem directories ilists dataRegions dnext inext ->
            if has name directories then
                let ino = lookupFName name directories
                    match ino with
                        Left ino ->
                             let directories' = removeDirectory name directories
                                 inode = lookupINode ino ilists
                                 match inode with
                                        Left inode ->
                                            match inode with
                                                INode ino loc ->
                                                    if loc > 1 then
                                                        let loc' = loc - 1
                                                            inode' = INode ino loc'
                                                            ilists' = modifyINode ino inode' ilists
                                                            FileSystem directories' ilists' dataRegions dnext inext
                                                    else
                                                        let ilists' = removeINode ino ilists
                                                            dataRegions' = removeDataRegion loc dataRegions
                                                            FileSystem directories' ilists' dataRegions' dnext inext
                                        Right () -> fs -- unreachable, we know the file exists
                        Right () -> fs -- no such file src
            else
                fs -- no such file


unique ability FileLU
       where
            link: (Text, Text) -> {FileLU } ()
            unlink: Text -> {FileLU } ()

fileLU : Request {FileLU} a ->{FileRW, State FileSystemT} a
fileLU result =
    match result with
        { link (src, dest) -> resume } ->
            let fs = get ()
                fs' = flink src dest fs
                put fs'
                handle resume () with fileLU
        { unlink name -> resume } ->
            let fs = get ()
                fs' = funlink name fs
                put fs'
                handle resume () with fileLU
        { result } -> result

fileIO m = handle (handle (handle !m with fileRW) with fileCO) with fileLU


{-
    pipes
    ======
-}

unique ability Await a
    where
        await: () -> {Await } a

unique ability Yield a
    where
        yield: a -> {Yield } ()

--pipe : '{Yield b, e} a -> '{Await b, e} a ->{e} a
--pipe p c = handle c () with
--                (cases
--                    { x } -> x
--                    { await () -> resume } -> copipe resume p)
--
--copipe : b -> {Await b, e} a -> '{yield b, e} a ->{e} a
--copipe p c = handle p () with
--                (cases
--                    { x } -> x
--                    { yield y -> resume } -> pipe ('resume) c y )

{-
    Process Syncronization
    ======================
-}

unique ability Co 
    where 
        ufork: () -> {Co } Nat
        wait: Nat -> {Co } ()
        uinterrupt: () -> {Co } ()

unique type Proc a e = Proc (Sstate a e ->{e} List (Nat, a))
unique type Pstate a e = Ready (Proc a e) | Blocked Nat (Proc a e)
unique type Sstate a e = {q: List (Nat, Pstate a e), done: List (Nat, a), pid: Nat, pnext: Nat}

runNext: Sstate a e ->{e} List (Nat, a)
runNext = cases Sstate q done pid pnext ->
    match q with
        [] -> done
        (pid', Blocked pid'' resume) +: q' -> runNext (Sstate (q' lib.base.data.List.++ [(pid', Blocked pid'' resume)]) done pid pnext)
        (pid', Ready resume) +: q' -> []

scheduler: Sstate a e -> Request {Co, e} a ->{e} List (Nat, a)
scheduler st request = match request with 
    { result } -> 
        let (Sstate q done pid pnext) = st 
            done' = done lib.base.data.List.++ [(pid, result)]
            runNext (Sstate q done' pid pnext)
    { ufork () -> resume } -> 
        let resume' = (Proc (st -> handle resume 0 with scheduler st))
            (Sstate q done pid pnext) = st
            pid' = pnext
            pnext' = pnext + 1
            q' = q lib.base.data.List.++ [(pid', Ready resume')]
            handle resume pid' with scheduler (Sstate q' done pid pnext')
    { wait pid -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = if processExists pid q then
                     q lib.base.data.List.++ [(pid, Blocked pid resume')]
                 else q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)
    { uinterrupt () -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)

processExists: Nat -> [(Nat, Pstate a e)] -> Boolean
processExists pid processes =
    match processes with
        [] -> false
        (pid', process) +: rest ->
            if pid == pid' then true
            else processExists pid rest

timeshare2 : '{g, Co} a ->{g} List (Nat, a)
timeshare2 m = handle !m with scheduler (Sstate [] [] 1 2)

init: '{e} a ->{e, Co} ()
init main = let pid = ufork ()
                if pid == 0 then
                    _ = main ()
                    ()
                else
                    wait pid

{-
    Permissions
    ============
-}

unique type Permission = Read | Write | AddUser


permissions: User -> Request {Session} a ->{Session, State [(Text, [Permission])]} a
permissions user request = 
    match request with
        {ask var -> resume} -> 
            let st = get ()
                perms = lookupPermission var st
                if allowed Read perms then
                    answer = ask var
                    handle resume answer with permissions user 
                else 
                    handle resume "" with permissions user -- fail, permission denied
        {su user' -> resume} -> 
            handle resume () with permissions (Username user')
        {adduser user' -> resume} -> 
            let st = get ()
                (Username username) = user
                perms = lookupPermission username st
                if allowed AddUser perms then
                    adduser user'
                    handle resume () with permissions user
                else 
                    handle resume () with permissions user -- fail, permission denied
        {export var val -> resume} -> 
            let st = get ()
                (Username username) = user
                perms = lookupPermission username st
                if allowed Write perms then
                    export var val
                    handle resume () with permissions user
                else 
                    handle resume () with permissions user -- fail, permission denied
        {result} -> result

lookupPermission: Text -> [(Text, [Permission])] -> [Permission]
lookupPermission var perms =
    match perms with
        [] -> []
        (var', perms') +: rest ->
            if var == var' then perms'
            else lookupPermission var rest

allowed: Permission -> [Permission] -> Boolean
allowed perm perms =
    match perms with
        [] -> false
        perm' +: rest ->
            if permEquals perm perm' then true
            else allowed perm rest

permEquals : Permission -> Permission -> Boolean
permEquals perms1 perms2 = 
    match perms1 with 
        Read -> 
            match perms2 with 
                Read -> true
                _ -> false
        Write -> 
            match perms2 with 
                Write -> true
                _ -> false
        AddUser -> 
            match perms2 with 
                AddUser -> true
                _ -> false


--nondet2 : Request {TimeSharing} a -> [a]
--nondet2 request =
--    match request with
--        { fork -> resume } -> let pid = ufork ()
--                                if pid == 0 then
--                                    handle resume true with nondet2
--                                else
--                                    handle resume false with nondet2
--        { result } -> [result]

 {-
    Util 
    ======
-}

--unique ability Logging
--    where
--        log: a -> {Logging } ()
--
--logHandler : Request {Logging} a -> a
--logHandler request =
--    match request with
--        { log x -> resume } -> putText stdOut x; handle resume () with logHandler
--        { result } -> result

{-
    Programs for write up
    ======================
-}

greetAndExit _ = echo "Hello, World!\n"; exit 1; echo "Goodbye, World!\n"

runGreetAndExit _ = handle (handle !greetAndExit with basicIO) with exitHandler

backwardsIO : Request {BasicIO} x ->{IO, Exception} () 
backwardsIO result = match result with
    { echo text -> resume } ->  
        handle resume () with basicIO 
        putText stdOut text;
    { result } -> ()

multiHandlers _ = echo "Hello,"; echo " World!\n"

runMultiHandlers _ = handle !multiHandlers with basicIO

{-
    Examples
    =========
-}

ioAndUsers : a ->{Session, Status, BasicIO} ()
ioAndUsers _ = 
    if whoami () == "root" then
        echo "Logged in as root\n";
        exit 0
    else
        echo "Permission denied\n";
        exit 1
    
--runIOandUsers _ = handle (handle (handle !ioAndUsers with sessionManager initialEnv) with exitHandler) with basicIO
    
ritchie _ = echo "UNIX is basically\n"; echo "a simple operating system\n"; echo "but you have to be a genius to understand the simplicity\n"
hamlet _ = echo "To be, or not to be,\n"; echo "that is the question:\n"; echo "Wether 'tis nobler in the mind to suffer\n";

forkAndIO : a ->{BasicIO, TimeSharing} ()
forkAndIO _ = 
    if fork then
        !ritchie
    else
        !hamlet

runForkAndIO _ = handle (handle !forkAndIO with basicIO) with nondet
        
--testProgram7 _ = handle (get (handle (handle (echo "Hello, World!\n") with systemIO) with fileRW)) with runState initialFileSystem

-- testProgram8 _ = timeshare2 (_ -> (handle (handle (if ufork () == 0 then [!ritchie] else [!hamlet]) with interruptWrite) with basicIO))
