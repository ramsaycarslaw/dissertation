{-
    BasicIO
    =========
-}

unique ability BasicIO
    where
        echo: Text -> {BasicIO } ()

basicIO : Request {BasicIO} x ->{IO, Exception} ()
basicIO result =
    match result with
        { echo text -> resume } -> putText stdOut text; handle resume () with basicIO
        { result } -> ()


{-
    Status
    =========
-}

-- The unix exit command that allows you to exit with error code
unique ability Status
       where
            exit: Nat -> ()

-- handles the exit command which just returns an integer
exitHandler : Request {g, Status} x -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> v

{-
Userspace
==========

This handles the hard coded users and their environments.
It allows for whoami and su commands to be run.

-}

-- The users (hard coded)
unique type User = Alice | Bob | Root
structural type Environment = Environment User

-- Each user has a unique environment
environments : List (User, Environment)
environments = [(Alice, Environment Alice),
                (Bob, Environment Bob),
                (Root, Environment Root)]

unique ability Session
    where
        su: User -> {Session } Environment
        whoami: {Session } Text

-- Helper function because unison cannot infer equity on custom types
userEquals: User -> User -> Boolean
userEquals user1 user2 =
    match user1 with
        Alice -> match user2 with
            Alice -> true
            _ -> false
        Bob -> match user2 with
            Bob -> true
            _ -> false
        Root -> match user2 with
            Root -> true
            _ -> false

-- returns the environment of a user, usually from the hard coded environments
envOf: (User, [(User, Environment)]) -> Environment
envOf t = match t with
    (user, envStore) ->
        match envStore with
            [] -> Environment user -- TODO add failure here
            (user', env) +: rest ->
                if userEquals user user' then env
                else envOf (user, rest)

sessionManager : Environment -> Request {Session} a -> a
sessionManager initial request =
    match request with
          { su user -> resume }
            -> newEnv = envOf (user, environments)
               -- We fecth the correct environment and then resume with it
               handle resume newEnv with sessionManager newEnv
          { whoami -> resume}
            -> match initial with
                -- this could probbaly be made generic with some User -> Text function
                Environment Alice -> handle resume "alice" with sessionManager initial
                Environment Bob -> handle resume "bob" with sessionManager initial
                Environment Root -> handle resume "root" with sessionManager initial
          { result } -> result

-- shorthand
initialEnv : Environment
initialEnv = envOf (Root, environments)

{-
      Time Sharing
   ==================
-}

unique ability Interrupt
    where
        interrupt: {Interrupt } ()


-- unique type PState a = Done a | Paused (Unit ->{Interrupt} a)
unique type PState a e = Done a | Paused ({e} PState a e)

interruptIO : Request {BasicIO} x ->{IO, Exception, Interrupt} ()
interruptIO result =
    match result with
        { echo text -> resume } -> interrupt; putText stdOut text; handle resume () with basicIO
        { result } -> ()

--reifyProcess : Request {Interrupt} a -> PState a e
--reifyProcess request =
--    match request with
--        { interrupt -> resume } -> ( handle resume with reifyProcess )
--        { result } -> Done result


reifyProcess request =
    match request with
        { interrupt -> resume } -> Paused (handle !resume with reifyProcess )
        { result } -> Done result

unique ability TimeSharing
    where
        fork: {TimeSharing } Boolean

-- handler for time sharing ability
nondet : Request {TimeSharing} a -> [a]
nondet request =
    match request with
        { fork -> resume } -> (handle resume true with nondet) lib.base.data.List.++ (handle resume false with nondet)
        { result } -> [result]

schedule : [PState a {TimeSharing}] -> [a]
schedule processes =
    match processes with
        [] -> []
        Done result +: rest -> result +: schedule rest
        Paused resume +: rest -> schedule (rest lib.base.data.List.++ (handle resume with nondet))

timeshare : '{e, Interrupt} a ->{e} [a]
timeshare m = schedule [Paused (handle !m with reifyProcess)]

{-
  Serial File System
  ==================
-}

unique ability State a
       where
            put: a -> ()
            get: () -> a

--runState : (b, Request {State b} a) -> (b, a)
--runState pair =
--    match pair with 
--        (s, request) ->
--        match request with
--            { result } -> (s, result)
--            { put s' -> resume } -> (s', resume ())
--            { get () -> resume } -> (s, resume s)

runState : a -> Request {State a} b -> b
runState v request =
    match request with
        { put v' -> resume } -> handle resume () with runState v'
        { get () -> resume } -> handle resume v with runState v
        { result } -> result

unique type DirectoryT = Directory (Text, Nat)
unique type DataRegionT = DataRegion (Nat, Text)
unique type INodeT = INode Nat Nat
unique type IListT = IList (Nat, INodeT)
unique type FileSystemT = FileSystem (List DirectoryT) (List IListT) (List DataRegionT) Nat Nat


initialINode : INodeT
initialINode = INode 0 0

initialDirectory : DirectoryT
initialDirectory = (Directory ("stdout", 0))

initialDataRegion : DataRegionT
initialDataRegion = DataRegion (0, "")

initialIList : IListT
initialIList = IList (0, initialINode)

initialFileSystem : FileSystemT
initialFileSystem = FileSystem [initialDirectory] [initialIList] [initialDataRegion] 0 0

unique ability FileRW
    where
        -- Read INode number -> File
        read: Nat -> {FileRW } Text
        -- Write INode number, Text -> ()
        write: (Nat, Text) -> {FileRW } ()


lookupINode : Nat -> [IListT] -> Either INodeT ()
lookupINode i ilists =
    match ilists with
        [] -> Right ()
        (IList (i', inode)) +: rest ->
            if i == i' then Left inode
            else lookupINode i rest

lookupFName : Text -> [DirectoryT] -> Either Nat ()
lookupFName name directories =
    match directories with
        [] -> Right ()
        (Directory (name', i)) +: rest ->
            if name == name' then Left i
            else lookupFName name rest

modifyINode : Nat -> INodeT -> [IListT] -> [IListT]
modifyINode i inode ilists =
    match ilists with
        [] -> []
        (IList (i', inode')) +: rest ->
            if i == i' then (IList (i, inode)) +: rest
            else (IList (i', inode')) +: modifyINode i inode rest

lookupDataRegion : Nat -> [DataRegionT] -> Either Text ()
lookupDataRegion i dataRegions =
    match dataRegions with
        [] -> Right ()
        (DataRegion (i', text)) +: rest ->
            if i == i' then Left text
            else lookupDataRegion i rest

modifyDataRegion : Nat -> Text -> [DataRegionT] -> [DataRegionT]
modifyDataRegion i text dataRegions =
    match dataRegions with
        [] -> []
        (DataRegion (i', text')) +: rest ->
            if i == i' then (DataRegion (i, (text' ++ text))) +: rest
            else (DataRegion (i', text')) +: modifyDataRegion i text rest

-- fread, implementation of system read
fread : Nat -> FileSystemT -> Either Text ()
fread i fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            match lookupDataRegion dataRegion dataRegions with
                                Left text -> Left text
                                Right () -> Right ()
                Right () -> Right ()

-- fwrite, writes to the file system at the given inode with the given text
fwrite : Nat -> Text -> FileSystemT -> FileSystemT
fwrite i text fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            FileSystem directories (modifyINode i (INode i dataRegion) ilists) (modifyDataRegion dataRegion text dataRegions) 0 0
                Right () -> fs

fopen : Text -> FileSystemT -> Nat
fopen name fs = 
    match fs with
        FileSystem directories ilists dataRegions dnext inext ->
            match lookupFName name directories with
                Left i -> i
                Right () -> inext

has : Text -> [DirectoryT] -> Boolean
has name directories =
    match directories with
        [] -> false
        (Directory (name', i)) +: rest ->
            if name == name' then true
            else has name rest

fcreate : Text -> FileSystemT -> (Nat, FileSystemT)
fcreate name fs = 
    match fs with 
        FileSystem directories ilists dataRegions dnext inext ->
            -- file already exists, overwrite it
            if has name directories then 
                let ino = (fopen name fs)
                    inode = lookupINode ino ilists
                    match inode with
                        Left inode -> 
                            match inode with 
                                INode ino loc ->
                                    let dreg' = modifyDataRegion loc "" dataRegions
                                        (ino , FileSystem directories ilists dreg' dnext inext)
                        Right () -> (ino, fs) -- unreacable
            else 
                let inext' = inext + 1
                    dnext' = dnext + 1
                    inode = INode inext dnext
                    ilists' = (IList (inext, inode)) +: ilists
                    directories' = (Directory (name, inext)) +: directories
                    (inext, FileSystem directories' ilists' dataRegions dnext' inext')

--fileRW : Request {FileRW} a -> State FileSystemT
--fileRW result =
--    match result with
--        -- { read i -> resume } -> let cs = (fread i get()) in resume cs
--        { write (i, text) -> resume } -> put (fwrite i text get()); handle resume () with fileRW
--        { result } -> result


{-
    Examples
    =========
-}

ioAndUsers : a ->{Session, Status, BasicIO} ()
ioAndUsers _ = 
    if whoami == "root" then
        echo "Logged in as root\n";
        exit 0
    else
        echo "Permission denied\n";
        exit 1
    
runIOandUsers _ = handle (handle (handle !ioAndUsers with sessionManager initialEnv) with exitHandler) with basicIO
    
ritchie _ = echo "UNIX is basically\n"; echo "a simple operating system\n"; echo "but you have to be a genius to understand the simplicity\n"
hamlet _ = echo "To be, or not to be,\n"; echo "that is the question:\n"; echo "Wether 'tis nobler in the mind to suffer\n";

forkAndIO : a ->{BasicIO, TimeSharing} ()
forkAndIO _ = 
    if fork then
        !ritchie
    else
        !hamlet

runForkAndIO _ = handle (handle !forkAndIO with basicIO) with nondet
        
{-
    Tests
    ======
-}

-- Test exiting
testProgram0 _ = exit 42
--> handle !testProgram0 with exitHandler

testProgram1 _ =
    whoami
--> handle !testProgram1 with whoamiHandler

testProgram2 _ =
    handle whoami with sessionManager (handle su Alice with sessionManager initialEnv)
--> handle !testProgram2 with sessionManager initialEnv

proc1 _ = handle [echo "Hello, ", echo "World!"] with basicIO
proc2 _ = handle [echo "Goodbye, ", echo "Code!"] with basicIO

testProgram3 _ =
    handle whoami with sessionManager (handle su Bob with sessionManager initialEnv)

testProgram4 _ =
    if fork then
        [handle whoami with sessionManager (handle su Bob with sessionManager initialEnv)]
     else
        [handle whoami with sessionManager (handle su Alice with sessionManager initialEnv)]
--> handle !testProgram4 with nondet

--ritchie _ = echo "UNIX is basically\n"; echo "a simple operating system\n"; echo "but you have to be a genius to understand the simplicity\n"
--hamlet _ = echo "To be, or not to be,\n"; echo "that is the question:\n"; echo "Wether 'tis nobler in the mind to suffer\n";

testProgram5 _ =
    handle (handle (if fork then [!ritchie] else [!hamlet]) with basicIO) with nondet

testProgram6 _ = schedule [(Paused (handle (handle !ritchie with interruptIO) with reifyProcess)), (Paused (handle (handle !hamlet with interruptIO) with reifyProcess))]
