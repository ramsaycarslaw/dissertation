\documentclass[logo,bsc,singlespacing,parskip]{infthesis}

\usepackage{ugcheck}

\usepackage{microtype}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{subcaption}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{gray}{HTML}{666666}		%#666666
\definecolor{lightbule}{HTML}{006699}		%#006699
\definecolor{lightgreen}{HTML}{669900}		%#669900
\definecolor{bluegreen}{HTML}{33997e}		%#33997e
\definecolor{magenta}{HTML}{d94a7a}		%#d94a7a
\definecolor{orange}{HTML}{e2661a}		%#e2661a
\definecolor{purple}{HTML}{7d4793}		%#7d4793
\definecolor{green}{HTML}{718a62}		%#718a62

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=none,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstdefinelanguage{unison}{
  %keyword1&2&6
  morekeywords = [1]{ability, type, handle, with, if, then, else, match, cases},
  %keyword3
  morekeywords = [2]{unique, structural},
  %keyword4
  morekeywords = [3]{Status, BasicIO, User, Environment, Session, PState, Done, Paused, Interrupt, TimeSharing, Alice, Bob, Root},
  %keyword5
  morekeywords = [4]{Nat, Text, List, Tuple, (), Request, Boolean, IO, Exception},
  keywordstyle = [1]\color{bluegreen},
  keywordstyle = [2]\color{lightgreen},
  keywordstyle = [3]\color{codepurple},
  keywordstyle = [4]\color{orange},
  sensitive = true,
  morecomment = [l]{--},
  morecomment = [s]{\{-}{-\}},
  commentstyle = \color{gray},
  morestring = [b]",
  stringstyle = \color{purple}
}

\lstdefinestyle{terminal}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  captionpos=b,
  xleftmargin=10pt,
  numbers=none,
}

\lstset{style=mystyle}


\begin{document}
\begin{preliminary}

\title{Implementing UNIX with Effects Handlers}
\author{Ramsay Carslaw}

\course{Computer Science}
\project{4th Year Project Report}

\date{\today}

% https://okmij.org/ftp/continuations/ZFS/context-OS.pdf
% https://dl.acm.org/doi/pdf/10.1145/800087.802786

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}

\begin{acknowledgements}
  Any acknowledgements go here.
\end{acknowledgements}

\tableofcontents

\end{preliminary}

\chapter{Introduction}

\chapter{Background}

\section{Algebraic Effects and Effect Handlers}

Algebraic effects \cite{plotkin2002computational} and their corresponding
handlers \cite{plotkin2009handlers} \cite{pretnar2015introduction} are a
programming paradigm that when paired together offers a novel way to compose
programs. It starts with the definition of the effect or the \emph{effect
signature} that gives the effect a name in scope and specifies any input and the
return type otherwise known as the \emph{effect operation}.  For example, we
might define the effect signature \emph{State} that stores state for some type
\texttt{a}. In order to make use of our \emph{State} effect we can define the
effect operations \emph{put} and \emph{get} where put will update the value of
type \texttt{a} stored in state and get will return the current value.  At this
stage the effect operation has no implementation and is more an acknowledgement
to the compiler that it should expect an implementation. For this reason any
function that references these effect operations is known as an \emph{effectful
function} or a function whose definition is not complete without an effect
handler. In the put and get example, any function that uses put and get to store
values would be an effectful function. The \emph{effect handler} provides one
implementation of the given effect operation. We could define a simple handler
for state that simply updates a variable of the given type or we could define a
more complex one that uses hash maps.  In this way, we can change the semantics
of an effectful function by handling it with a different handler that provides
an alternative implementation to the effect. Crucially, we can have multiple
handlers defined in the same program for one effect allowing for much more
modular programming or \emph{effect-oreinted programming}.

When are programs rely on input from the real world like connecting to a server
on the internet or getting input from a user, it is no longer safe to assume
this input will be passed as we expect. For example, the server could time out
or not be at the address the program is expecting it to be at or the user could
enter a string that is too long for the input. These real world uncertainties
are known as \emph{Side Effects}. Effect handlers can be used to provide
alternate implementations of functions that may have side effects and allow for
control flow with these effects.

\subsection{Example in Unison}
\label{subsection:unison}

Unison \footnote{https://github.com/unisonweb/unison} is a
functional language implemented in Haskell that offers built in support for effect
handlers through it's abilities system.

Unison provides the \emph{ability} keyword which allows users to define their own
effects. It also provides the \emph{handle ... with ...} pattern to attach handlers to effectful functions.

\begin{lstlisting}[caption={The \emph{put} and \emph{store} example in Unison. Note that the \emph{structural} keyword refers to the fact that Unison stores type definitions as a hash. Even if we changed all the variable names it would still view it as the same type. To avoid that behaviour you can swap the \emph{structural} keyword for \emph{unique}}]
structural ability Store a where
  put: a -> {Store a} ()
  get: {Store a} a
\end{lstlisting}

This defines the two effect operations \texttt{put} and \texttt{get} that have
the effect signature \texttt{Store a}. Put takes a value of type \texttt{a} and
returns the unit type \texttt{()}. The prefix of \texttt{\{Store a\}} to the
\texttt{()}, refers to the fact that in order to allow for \texttt{put} to
return, it must be run from an effectful function that is handled with an
appropriate handler for \texttt{Store a}. Similarly, \texttt{put} takes an
argument of type \texttt{a} and must be handled.

\begin{lstlisting}[language=unison, caption={An example of an effectful function that uses the \texttt{Store} effect}]
addStore : a -> {Store a} ()
addStore x =
  y = get
  put (x + y)
\end{lstlisting}
\label{listing:addstore}

The code in listing \ref{listing:addstore} is an example of how you would use
the effects in Unison. It takes an argument of type \texttt{a} and `adds' it to
the current value by using \texttt{get}. Note that in order for this to work the
infix operation `+' must be implemented for type \texttt{a}. Now we only need to
define the handler.

\begin{lstlisting}[caption={The handler for the \texttt{Store} effect}]
    storeHandler : a -> Request (Store a) a -> a
    storeHandler value = cases
        {Store.get -> resume} -> handle resume value with storeHandler value
        {Store.put v -> resume} handle resume () with storeHandler v
        {result} -> result

\end{lstlisting}

The handlers in Unison use tail recursion to reduce to the case where just the
value is left \texttt{result -> result}. For both store and put we use the
resumption and the handler to reach the final value. The special type
\texttt{Request} allows us to perform pattern matching on the possible types of
the computation.

\begin{lstlisting}
handle (addStore 10) with storeHandler 10
\end{lstlisting}

Finally, we can put it all together by calling the function \texttt{addStore}
with the handler \texttt{storeHandler}. 

\section{Affine and `Multi-Shot' Handlers}

If remaining computation or continuation of an effect can be resumed once from
a handler then the effect system implements \emph{one-shot} or \emph{affine}
effect handlers. If it is able to resume the computation multiple times then it
is a \emph{multi-shot} handler. 

\section{The State of Effect-Oriented Programming}

\subsection{Library Based Effects}

\begin{itemize}
        \item{libhandler \cite{leijen2017implementing} is a portable c99 library
that implements algebraic effect handlers for C. It implements high performance
multi-shot effects using standard C functions. It is limited by the assumptions
it makes about the stack such as it being contiguous and not moving. In practice
this could lead to memory leaks if it copies pointers.}
        \item{libmprompt \footnote{https://github.com/koka-lang/libmprompt} is a
C/C++ library that adds effect handlers. It uses virtual memory to solve the
problem mentioned with libhandler. By keeping the stack in a fixed location in
virtual memory it restores safety. It also provides the higher level libmpeff
interface. A downside is they recommend at least 2GiB of virtual memory to
allow for 16000 stacks which may be challenging on some systems.}
        \item{cpp-effects \cite{DBLP:journals/pacmpl/GhicaLBP22} is a C++
implementation of effect handlers. It uses C++ template classes and types to
create modular effects and handlers. It's performance has been shown to be
comparable to C++20 coroutines. It's limitations are it only supports one-shot
        resumptions.}
        \item{There are several Haskell libraries that implement effect handlers
\cite{DBLP:conf/haskell/XieL20, DBLP:conf/haskell/KiselyovI15,
DBLP:conf/haskell/WuSH14}. Some are discussed in more detail below.}
        \begin{itemize}
          \item{EvEff uses lambda calculus based evidence translation to
implement it's effects system. It provides deep effects.}
          \item{fused-effects
\footnote{https://hackage.haskell.org/package/fused-effects} fuses the effect
handlers it provides with computation by applying \emph{fusion laws} that avoid
intermediate representation. The handlers in fused-effects are one-shot
however.}
        \end{itemize}
\end{itemize}

\subsection{First-Class Effects}

\begin{itemize}
        \item{Unison is shown in more detail in section \ref{subsection:unison}}
        \item{Koka \cite{DBLP:journals/corr/Leijen14} is a statically typed
functional language with effect types and handlers. It can also compile
straight to C code without needing a garbage collector. Koka is developed by a
small team and as such is still missing much of its standard library.}
        \item{Frank \cite{DBLP:conf/popl/LindleyMM17} is a strict functional
language that is \emph{effectful} in that it has first class support for
bi-directional effects and effect handlers. }
        \item{Links \cite{DBLP:conf/fmco/CooperLWY06} is a functional
programming language designed for the web. Out of the box it does not support
true algebraic effects, however through an extension
\cite{DBLP:conf/icfp/HillerstromL16} it gains first class support for
continuations.}
\end{itemize}

\section{Shallow vs. Deep Effect Handlers}

There are two types of effect handler implementation, \emph{deep handlers}, as
originally defined by Plotkin and Pretnar \cite{plotkin2009handlers} and
\emph{shallow handlers} \cite{hillerstrom2018shallow}. Deep handlers pass a
copy of the full handler along with the computation which allows for the
handler to be invoked again as the handlers receive themselves as an argument.
Shallow handlers do not pass the handler with the computation. There are also
\emph{sheep handlers}, which while being shallow implement some of the
behaviour of deep handlers leading to the name sheep or shallow + deep. In
practice, the type of handler is more of an implementation detail although it
can have an effect on how code is structured.

\section{\textsc{UNIX}}

\textsc{Unix} \cite{ritchie1978unix} is an operating system designed and
implemented by Dennis M. Ritchie and Ken Thompson at AT\&T's Bell Labs in 1974.
It provides a file system (directories, file protection etc.), a shell,
processes (pipe, fork etc) and a userspace. Since it's first release it has been
reimplemented for a variety of systems.

\subsection{The UNIX Philosophy}

A phrase often associated with \textsc{Unix} is the \emph{Unix philosophy}.  The
\textsc{Unix} philosophy refers to some of the core principles with which it was
developed. The core principles involve composing many small simple programs that
accomplish one task well to solve more complex tasks \cite{raymond2003art}. The
idea of many small modular components has spread to many areas of computer
science including effect oriented programming.

\section{Effect Based File Systems}

Continuations in operating systems \cite{DBLP:conf/context/KiselyovS07}.

\section{Effect Handlers and UNIX}

In chapter 2 of his 2022 thesis, Daniel Hillerstr\"{o}m
\cite{hillerstrom2022foundations} outlines a theoretical implementation of UNIX
using the effects syntax outlined by Kammar et. al. \cite{kammar2013handlers}.
In this he provides an implementation of the original \textsc{Unix} paper
\cite{ritchie1978unix} that includes a filesystem and timesharing.
Hillerstr\"{o}m makes several assumptions about the effect system that would
need to be taken into account in order to implement this with a real language.
The main assumption is multi-shot handlers. For example the implementation of
\texttt{fork} uses multi-shot handlers to copy the full stack on both branches.
There are also some partial implementations such as \texttt{sed} \footnote{It is
worth mentioning \texttt{sed} has $20,000+$ lines of code} from which he only
implements string replacement.

\chapter{Base Implementation}

\section{Effect Oriented Programming in Unison}

As is shown in section \ref{subsection:unison}, effect oriented programming in
Unison is composed of an effect definition with an effect signature and a set
of effect operations and any handlers for that effect signature.

\section{Program Status}
\label{status}

In \texttt{Unix} programs must provide a code when they exit (usually 0 for
success and anything else for failure). The effect signature \texttt{Status}
provides the \texttt{exit} operation which takes one argument of type
\texttt{Nat} \footnote{a positive integer in Unison} and returns the unit type.
A better definition would have exit return the empty type but unison does not
have an empty type. The argument represents the return code.

\begin{lstlisting}[language=unison]
unique ability Status
       where
            exit: Nat -> ()
\end{lstlisting}

\subsection{Unique vs. Structural Types}

In Unison, \texttt{unique} types are used when the name of the type is
semantically important. The alternative is \texttt{structural} types which are
used when the name of the type is not important and it can be stored as a hash
without it's name. \texttt{unique} types are used for all effects as it has no
real implication given the program is not distributed.

\subsection{The Handler}

The handler for \texttt{Status} is defined as:

\begin{lstlisting}[language=unison]
exitHandler : Request {e, Status} x -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> abort
\end{lstlisting}

The implementation for exit has no effect it simply consumes the exit code and
returns. The handler however returns a \texttt{Nat} return code. If an exit
operation is encountered we return the value given to the exit operation. The
return case simply returns 0 as if we reach the end of a function being handled
by the handler then we can assume it was successful and return 0.


\subsection{The Request Type}

The \texttt{Request} type is a special type in Unison that allows for pattern
matching on operations of an effect. In the braces are the effect types for the
handler. The \texttt{Status} is the effect signature that is explicitly being
handled. The \texttt{e} allows for any other effects in the computation to be
passed through. The \texttt{x} is the return type of the computation.

\section{Basic I/O}
\label{io}

The \emph{effect signature} \texttt{BasicIO} is used for simple I/O operations.
The first and only \emph{effect operation} of \texttt{BasicIO} is \texttt{echo}
which takes an argument of type \texttt{Text} and returns the unit
type \texttt{()}. 

\begin{lstlisting}[language=unison]
unique ability BasicIO where
  echo: Text -> ()
\end{lstlisting}

The handler for \texttt{BasicIO} is simply a wrapper for Unison's
\texttt{putText} function which it uses to print the given text to
\texttt{stdout}. It then handles the resumption with the same handler to handle
any further \texttt{echo} calls.

\begin{lstlisting}[language=unison]
basicIO : Request {BasicIO} x ->{IO, Exception} ()
basicIO result =
    match result with
        { echo text -> resume } -> 
          putText stdOut text; 
          handle resume () with basicIO
        { result } -> ()
\end{lstlisting}

\subsection{IO and Exception abilities}

The handler for \texttt{BasicIO} uses the \texttt{putText} function from
Unison's standard library because of this we must include the \texttt{\{IO,
Exeption\}} in the type signature to indicate that this function needs access
to both the \texttt{IO} and \texttt{Exception} abilities in order to be run.
Both of these abilities are built in and used for all input and output in
unison.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]

\section*{Program 1 --- Hello World}

By combining the operations of Status and BasicIO we can write a simple program that prints ``Hello, World!" and then exits with the successful error code. Notice that the operations are invoked in the same way as functions. In this case they are being used inside a function. It would be possible to implement a simple shell for these commands however that is outside the scope of this project.

\begin{lstlisting}[language=unison]
greetAndExit : a ->{BasicIO, Status} ()
greetAndExit _ = echo "Hello, World!\n"; exit 0
\end{lstlisting}

By composing the two handlers in sections \ref{status} and \ref{io} we can run the program.

\begin{lstlisting}[language=unison]
runGreetAndExit _ = handle (handle !greetAndExit with basicIO) with exitHandler
\end{lstlisting}

By running this function with the unison codebase manager we get

\begin{lstlisting}[style=terminal]
Hello, World!

  0
\end{lstlisting}
\end{tcolorbox}

\subsection{Defining Multiple Handlers}

Effects are not limited to just one handler. The semantics of echo can be
changed without altering it's definition. For example, the \texttt{backwardsIO}
handler below.

\begin{lstlisting}[language=unison]
backwardsIO : Request {BasicIO} x ->{IO, Exception} () 
backwardsIO result =
  match result with
  { echo text -> resume } -> 
    handle resume () with basicIO 
    putText stdOut text;
  { result } -> ()
\end{lstlisting}

In this case, the resumption is handled first and then the text is printed. The
effect of this is best shown by running it side by side with \texttt{basicIO}
on the following program.

\begin{lstlisting}[language=unison]
helloworld _ = echo "Hello,"; echo " World!\\n"
\end{lstlisting}

The output of running this program with each handler is shown in Figure \ref{fig:sidebyside}.

\begin{figure}[h]
  \label{fig:sidebyside}
\begin{minipage}{0.5\textwidth}

\begin{lstlisting}[style=terminal]
> handle !helloworld with basicIO

Hello, World!

  ()
\end{lstlisting}

\end{minipage}%
\begin{minipage}{0.5\textwidth}

\begin{lstlisting}[style=terminal]
 > handle !helloworld with backwardsIO

 World!
Hello,
  ()
\end{lstlisting}
\end{minipage}
\caption{The output of running \texttt{helloworld} with each handler.}
\end{figure}

\section{Users and Environment}

To introduce the concept of a user-space and users we can start by adding some
hard coded users. For now, alice, bob and a root user: \texttt{unique type User
= Alice | Bob | Root}. To add generic users we could replace the definition with 
\texttt{unique type User = Text}, this would allow for the creation of new users.

Next we introduce the \texttt{Session} signature for operations involving
users. The operation \texttt{su} or \emph{substitute user} is used to change
the environment to that of a different user. The \texttt{ask} operation can be
used to access environment variables. Since the only variable we have now is
\texttt{USER} the argument to ask is a unit.

\begin{lstlisting}[language=unison]
unique ability Session
    where
        su: User -> {Session } ()
        ask: () -> {Session } Text
\end{lstlisting}

We can now implement the \textsc{Unix} command \texttt{whoami} with a wrapper
around ask.

\begin{lstlisting}[language=unison]
whoami: '{Session} Text
whoami _ = ask ()
\end{lstlisting}

\subsection{The Apostrophe in Unison}

The \texttt{'} character in Unison is syntactic sugar for a function with a
unit as the type of it's first argument. For example, the type signature of 
\texttt{whoami} could be rewritten as \texttt{() ->\{Session\} Text}. This is 
equivalent to \texttt{'\{Session\} Text}.

\subsection{Environment as a handler}

The handler for \texttt{Session} also takes a user as an argument, this is the
user that is currently logged in. To switch user we simply handle the rest of
the computation with the new user provided as the argument to \texttt{su}. Then
when the computation ends we will be back in the environment of the old user.

Due to the single environment variable being \texttt{USER}, \texttt{ask}
performs the action of \texttt{whoami}. It keeps the user the same and returns
the user as a string.

\begin{lstlisting}[language=unison]
env: User -> Request {Session} a -> a
env user request = 
    match request with
        {result} -> result
        { ask () -> resume } -> match user with 
            Alice -> handle resume "alice" with env user
            Bob -> handle resume "bob" with env user
            Root -> handle resume "root" with env user
        {su user' -> resume} -> handle resume () with env user'
\end{lstlisting}

In this way the environment is the handler itself as it contains the
information such as which user is logged in. The handler can be extended to
have parameterised environment variables making it the complete environment.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 2 --- Session Management}
  
  We can now compose the handlers we have written so far to switch between the
  users and invoke \texttt{whoami}.

  \begin{lstlisting}[language=unison]
    session _ = su Alice
                echo (!whoami)
                echo "\n"
                su Bob
                echo (!whoami)
                echo "\n"
                su Root
                echo(!whoami)
                echo "\n"
  \end{lstlisting}


  \begin{lstlisting}[language=unison]
    runsession _ = handle (handle (handle !session with env Root) with basicIO) with exitHandler
  \end{lstlisting}

  The \texttt{env} handler requires we give the user that is logged in
  initially as an argument so we pass \texttt{Root}. Notice we also handle the
  program with the \texttt{exitHandler} even though we do not invoke
  \texttt{exit} in the program. This is because by handling code with no \texttt{exit}'s
  with the \texttt{exitHandler} we will get the return case which will return 0
  indicating the program was successful.

  \begin{lstlisting}[style=terminal]
    alice
    bob
    root
      
      0
\end{lstlisting}
\end{tcolorbox}


\section{Nondeterminism}

To implement the \texttt{fork} command from \textsc{Unix} we can leverage
deliberate non-determinism that is possible with effect handlers. We define the
\texttt{fork} operation which returns a \texttt{Boolean} as a member of the
\texttt{TimeSharing} signature.

\begin{lstlisting}[language=unison]
unique ability TimeSharing
    where
        fork: Boolean
\end{lstlisting}

To use \texttt{fork} we can simply use it in control flow to create a branch.
Where normally only one branch would be executed, the two branches become our
two processes. For example:

\begin{lstlisting}[language=unison]
...
if fork then 
  process1 ()
else 
  process2 ()
...
\end{lstlisting}

The handler for fork is also fairly simple:

\begin{lstlisting}[language=unison]
nondet : Request {TimeSharing} a -> [a]
nondet request =
    match request with
        { fork -> resume } -> (handle resume true with nondet) lib.base.data.List.++ (handle resume false with nondet)
        { result } -> [result]
\end{lstlisting}

The handler returns a list of values with the type \texttt{a} which is the
return type of the computation. When we encounter a \texttt{fork} we resume
with the values true and false and join the two lists that are created. The
return case wraps the value in a list so that we can use the \texttt{++}
operator.

\subsection{Joining Lists in Unison}

Unison's typechecker sometimes struggles inferring the type of \texttt{++}. For
this reason we include the full path to the standard library where \texttt{++}
is defined i.e. \texttt{lib.base.data.List.++}.

\section{Scheduling}

Now that we can create processes through \texttt{fork} it would be useful to be able to write scheduling algorithms. Currently \texttt{fork} will run the first process to completion, and then run the second process to completion. To begin scheduling we need to give the processes a method of stopping execution and giving control to the other process. We introduce the \texttt{Interrupt} signature with one operation also called \texttt{interrupt}.

\begin{lstlisting}[language=unison]
unique ability Interrupt
    where
        interrupt: {Interrupt } ()
\end{lstlisting}

Now that we have \texttt{interrupt} we can write an alternative handler for
\texttt{BasicIO} that will \texttt{interrupt} before every IO operation,
allowing for the other process to run first.

\begin{lstlisting}[language=unison]
interruptWrite : Request {e, BasicIO} x ->{e, Interrupt, BasicIO} ()
interruptWrite result =
    match result with
        { echo text -> resume } -> 
            interrupt
            echo text 
            handle resume () with interruptWrite
        { result } -> ()
\end{lstlisting}

Note that we still need to provide a handler for \texttt{echo}, this handler
simply injects interrupt in front of every instance of \texttt{echo}.

In order to schedule processes we need to introduce state. Each process can either be \texttt{Done} (It has produced a return value) or \texttt{Paused} (It has been interrupted). \texttt{Paused} is a recursive definition as it contains a \texttt{PState} in it's type.

\begin{lstlisting}[language=unison]
unique type PState a e = Done a | Paused ('{e} PState a e)
\end{lstlisting}

The type \texttt{a} is the return type of the process and the \texttt{e} is an
effect variable that represents any effects that are needed to run the
\texttt{PState}. We can now implement the handler for \texttt{interrupt}.

\begin{lstlisting}[language=unison]
reifyProcess : Request {Interrupt, e} a -> PState a e
reifyProcess request =
    match request with
        { interrupt -> resume } -> Paused (_ -> handle !resume with reifyProcess )
        { result } -> Done result
\end{lstlisting}

In the case of an interrupt, the handler suspends the computation by making it
an anonymous function with a unit type as it's first argument, and wrapping it
in the paused datatype. This means we can run the \texttt{Paused} computations
later by invoking that function we created. The return case simply wraps the
value in the \texttt{Done} type.

\begin{lstlisting}[language=unison]
sched : [PState a {e, TimeSharing}] -> [a] ->{e} [a]
sched ps done = 
    match ps with
        [] -> done
        (Done res) +: ps' -> sched ps' (res lib.base.data.List.+: done)
        (Paused m) +: ps' -> sched (ps' lib.base.data.List.++ (handle !m with nondet)) done

timeshare : '{g, Interrupt, TimeSharing} o ->{g} [o]
timeshare m = sched [Paused (_ -> handle !m with reifyProcess)] []
\end{lstlisting}

\section{Serial File System}

\section{Pipes}

\section{Unix Fork}

\chapter{Extensions}

\section{Environment Variables}

\begin{lstlisting}[language=unison]
unique type User = Alice | Bob | Root

unique ability Session
    where
        su: User -> ()
        ask: Text -> Text
        export: Text -> Text -> ()

whoami: '{Session} Text
whoami _ = ask "USER"

env: User -> Request {Session} a ->{State [(User, [(Text, Text)])]} a
env user request = 
    match request with
        {result} -> result

        { ask var -> resume } -> 
            match var with 
                "USER" ->
                    match user with 
                        Alice -> handle resume "alice" with env user
                        Bob -> handle resume "bob" with env user
                        Root -> handle resume "root" with env user
                var -> 
                    let st = get ()
                        envs = lookupEnvs user st
                        val = lookupEnvVar var envs
                        handle resume val with env user

        {su user' -> resume} -> 
            handle resume () with env user'

        {export var val -> resume} -> 
            let st = get ()
                envs = lookupEnvs user st
                envs' = modifyEnvVar var val envs
                put (modifyEnvs user envs' st) 
                handle resume () with env user

lookupEnvVar: Text -> [(Text, Text)] -> Text
lookupEnvVar var env =
    match env with
        [] -> ""
        (var', val) +: rest ->
            if var == var' then val
            else lookupEnvVar var rest

modifyEnvVar: Text -> Text -> [(Text, Text)] -> [(Text, Text)]
modifyEnvVar var val env =
    match env with
        [] -> [(var, val)]
        (var', val') +: rest ->
            if var == var' then (var, val) +: rest
            else (var', val') +: modifyEnvVar var val rest

lookupEnvs: User -> [(User, [(Text, Text)])] -> [(Text, Text)]
lookupEnvs user envs =
    match envs with
        [] -> []
        (user', env) +: rest ->
            if userEquals user user' then env
            else lookupEnvs user rest

modifyEnvs: User -> [(Text, Text)] -> [(User, [(Text, Text)])] -> [(User, [(Text, Text)])]
modifyEnvs user env envs =
    match envs with
        [] -> [(user, env)]
        (user', env') +: rest ->
            if userEquals user user' then (user, env) +: rest
            else (user', env') +: modifyEnvs user env rest

userEquals: User -> User -> Boolean
userEquals user user' =
    match user with
        Alice -> 
            match user' with 
                Alice -> true
                _ -> false
        Bob -> 
            match user' with 
                Bob -> true
                _ -> false
        Root -> 
            match user' with 
                Root -> true
                _ -> false
\end{lstlisting}

\section{Generic Users}

\begin{lstlisting}[language=unison]
unique type User = Username Text

unique ability Session
    where
        su: Text -> ()
        ask: Text -> Text
        export: Text -> Text -> ()
        adduser: Text -> ()

whoami: '{Session} Text
whoami _ = ask "USER"

env: User -> Request {Session} a ->{State [(User, [(Text, Text)])]} a
env user request = 
    match request with
        {result} -> result

        { ask var -> resume } -> 
           let st = get ()
               envs = lookupEnvs user st
               val = lookupEnvVar var envs
               handle resume val with env user

        {su user' -> resume} -> 
            if userExists (Username user') (get ()) then
                handle resume () with env (Username user')
            else 
                handle resume () with env user   -- fail

        {export var val -> resume} -> 
            let st = get ()
                envs = lookupEnvs user st
                envs' = modifyEnvVar var val envs
                put (modifyEnvs user envs' st) 
                handle resume () with env user

        {adduser user' -> resume} ->
            if userToText user == "root" then
                let st = get ()
                    newuser = (Username user')
                    newvars = [("USER", user')]
                    newenv = modifyEnvs newuser newvars st
                    if (userExists newuser st) then
                        put newenv
                        handle resume () with env newuser
                    else 
                        handle resume () with env user
            else 
                handle resume () with env user   -- fail

lookupEnvVar: Text -> [(Text, Text)] -> Text
lookupEnvVar var env =
    match env with
        [] -> ""
        (var', val) +: rest ->
            if var == var' then val
            else lookupEnvVar var rest

modifyEnvVar: Text -> Text -> [(Text, Text)] -> [(Text, Text)]
modifyEnvVar var val env =
    match env with
        [] -> [(var, val)]
        (var', val') +: rest ->
            if var == var' then (var, val) +: rest
            else (var', val') +: modifyEnvVar var val rest

lookupEnvs: User -> [(User, [(Text, Text)])] -> [(Text, Text)]
lookupEnvs user envs =
    match envs with
        [] -> []
        (user', env) +: rest ->
            if userToText user == userToText user' then env
            else lookupEnvs user rest

modifyEnvs: User -> [(Text, Text)] -> [(User, [(Text, Text)])] -> [(User, [(Text, Text)])]
modifyEnvs user env envs =
    match envs with
        [] -> [(user, env)]
        (user', env') +: rest ->
            if userToText user == userToText user' then (user, env) +: rest
            else (user', env') +: modifyEnvs user env rest

userExists: User -> [(User, [(Text, Text)])] -> Boolean
userExists user envs =
    match envs with
        [] -> false
        (user', env) +: rest ->
            if userToText user == userToText user' then true
            else userExists user rest

userToText: User -> Text
userToText user = 
    let (Username username) = user
        username

initialUserspace : [(User, [(Text, Text)])]
initialUserspace = [(Username "root", [("USER", "root")] )]
\end{lstlisting}

\chapter{Evaluation}

\chapter{Conclusion}

\bibliographystyle{unsrt}
\bibliography{diss}

\end{document}
