\documentclass[logo,bsc,singlespacing,parskip]{infthesis}

\usepackage{ugcheck}

\usepackage{microtype}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{tcolorbox}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{gray}{HTML}{666666}		%#666666
\definecolor{lightbule}{HTML}{006699}		%#006699
\definecolor{lightgreen}{HTML}{669900}		%#669900
\definecolor{bluegreen}{HTML}{33997e}		%#33997e
\definecolor{magenta}{HTML}{d94a7a}		%#d94a7a
\definecolor{orange}{HTML}{e2661a}		%#e2661a
\definecolor{purple}{HTML}{7d4793}		%#7d4793
\definecolor{green}{HTML}{718a62}		%#718a62

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=none,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstdefinelanguage{unison}{
  %keyword1&2&6
  morekeywords = [1]{ability, type, handle, with, if, then, else, match, cases},
  %keyword3
  morekeywords = [2]{unique, structural},
  %keyword4
  morekeywords = [3]{Status, BasicIO, User, Environment, Session, PState, Done, Paused, Interrupt, TimeSharing, Alice, Bob, Root},
  %keyword5
  morekeywords = [4]{Nat, Text, List, Tuple, (), Request, Boolean, IO, Exception},
  keywordstyle = [1]\color{bluegreen},
  keywordstyle = [2]\color{lightgreen},
  keywordstyle = [3]\color{codepurple},
  keywordstyle = [4]\color{orange},
  sensitive = true,
  morecomment = [l]{--},
  morecomment = [s]{\{-}{-\}},
  commentstyle = \color{gray},
  morestring = [b]",
  stringstyle = \color{purple}
}

\lstdefinestyle{terminal}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  captionpos=b,
  xleftmargin=10pt,
  numbers=none,
}

\lstset{style=mystyle}


\begin{document}
\begin{preliminary}

\title{Implementing UNIX with Effects Handlers}
\author{Ramsay Carslaw}

\course{Computer Science}
\project{4th Year Project Report}

\date{\today}

% https://okmij.org/ftp/continuations/ZFS/context-OS.pdf
% https://dl.acm.org/doi/pdf/10.1145/800087.802786

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}

\begin{acknowledgements}
  Any acknowledgements go here.
\end{acknowledgements}

\tableofcontents

\end{preliminary}

\chapter{Introduction}

\chapter{Background}

\section{Algebraic Effects and Effect Handlers}

Algebraic effects \cite{plotkin2002computational} and their corresponding
handlers \cite{plotkin2009handlers} \cite{pretnar2015introduction} are a
programming paradigm that when paired together offers a novel way to compose
programs. It starts with the definition of the effect or the \emph{effect
signature} that gives the effect a name in scope and specifies any input and the
return type otherwise known as the \emph{effect operation}.  For example, we
might define the effect signature \emph{State} that stores state for some type
\texttt{a}. In order to make use of our \emph{State} effect we can define the
effect operations \emph{put} and \emph{get} where put will update the value of
type \texttt{a} stored in state and get will return the current value.  At this
stage the effect operation has no implementation and is more an acknowledgement
to the compiler that it should expect an implementation. For this reason any
function that references these effect operations is known as an \emph{effectful
function} or a function whose definition is not complete without an effect
handler. In the put and get example, any function that uses put and get to store
values would be an effectful function. The \emph{effect handler} provides one
implementation of the given effect operation. We could define a simple handler
for state that simply updates a variable of the given type or we could define a
more complex one that uses hash maps.  In this way, we can change the semantics
of an effectful function by handling it with a different handler that provides
an alternative implementation to the effect. Crucially, we can have multiple
handlers defined in the same program for one effect allowing for much more
modular programming or \emph{effect-oreinted programming}.

When are programs rely on input from the real world like connecting to a server
on the internet or getting input from a user, it is no longer safe to assume
this input will be passed as we expect. For example, the server could time out
or not be at the address the program is expecting it to be at or the user could
enter a string that is too long for the input. These real world uncertainties
are known as \emph{Side Effects}. Effect handlers can be used to provide
alternate implementations of functions that may have side effects and allow for
control flow with these effects.

\subsection{Example in Unison}
\label{subsection:unison}

Unison \footnote{https://github.com/unisonweb/unison} is a
functional language implemented in Haskell that offers built in support for effect
handlers through it's abilities system.

Unison provides the \emph{ability} keyword which allows users to define their own
effects. It also provides the \emph{handle ... with ...} pattern to attach handlers to effectful functions.

\begin{lstlisting}[caption={The \emph{put} and \emph{store} example in Unison. Note that the \emph{structural} keyword refers to the fact that Unison stores type definitions as a hash. Even if we changed all the variable names it would still view it as the same type. To avoid that behaviour you can swap the \emph{structural} keyword for \emph{unique}}]
structural ability Store a where
  put: a -> {Store a} ()
  get: {Store a} a
\end{lstlisting}

This defines the two effect operations \texttt{put} and \texttt{get} that have
the effect signature \texttt{Store a}. Put takes a value of type \texttt{a} and
returns the unit type \texttt{()}. The prefix of \texttt{\{Store a\}} to the
\texttt{()}, refers to the fact that in order to allow for \texttt{put} to
return, it must be run from an effectful function that is handled with an
appropriate handler for \texttt{Store a}. Similarly, \texttt{put} takes an
argument of type \texttt{a} and must be handled.

\begin{lstlisting}[language=unison, caption={An example of an effectful function that uses the \texttt{Store} effect}]
addStore : a -> {Store a} ()
addStore x =
  y = get
  put (x + y)
\end{lstlisting}
\label{listing:addstore}

The code in listing \ref{listing:addstore} is an example of how you would use
the effects in Unison. It takes an argument of type \texttt{a} and `adds' it to
the current value by using \texttt{get}. Note that in order for this to work the
infix operation `+' must be implemented for type \texttt{a}. Now we only need to
define the handler.

\begin{lstlisting}[caption={The handler for the \texttt{Store} effect}]
    storeHandler : a -> Request (Store a) a -> a
    storeHandler value = cases
        {Store.get -> resume} -> handle resume value with storeHandler value
        {Store.put v -> resume} handle resume () with storeHandler v
        {result} -> result

\end{lstlisting}

The handlers in Unison use tail recursion to reduce to the case where just the
value is left \texttt{result -> result}. For both store and put we use the
resumption and the handler to reach the final value. The special type
\texttt{Request} allows us to perform pattern matching on the possible types of
the computation.

\begin{lstlisting}
handle (addStore 10) with storeHandler 10
\end{lstlisting}

Finally, we can put it all together by calling the function \texttt{addStore}
with the handler \texttt{storeHandler}. 

\section{Affine and `Multi-Shot' Handlers}

If remaining computation or continuation of an effect can be resumed once from
a handler then the effect system implements \emph{one-shot} or \emph{affine}
effect handlers. If it is able to resume the computation multiple times then it
is a \emph{multi-shot} handler. 

\section{The State of Effect-Oriented Programming}

\subsection{Library Based Effects}

\begin{itemize}
        \item{libhandler \cite{leijen2017implementing} is a portable c99 library
that implements algebraic effect handlers for C. It implements high performance
multi-shot effects using standard C functions. It is limited by the assumptions
it makes about the stack such as it being contiguous and not moving. In practice
this could lead to memory leaks if it copies pointers.}
        \item{libmprompt \footnote{https://github.com/koka-lang/libmprompt} is a
C/C++ library that adds effect handlers. It uses virtual memory to solve the
problem mentioned with libhandler. By keeping the stack in a fixed location in
virtual memory it restores safety. It also provides the higher level libmpeff
interface. A downside is they recommend at least 2GiB of virtual memory to
allow for 16000 stacks which may be challenging on some systems.}
        \item{cpp-effects \cite{DBLP:journals/pacmpl/GhicaLBP22} is a C++
implementation of effect handlers. It uses C++ template classes and types to
create modular effects and handlers. It's performance has been shown to be
comparable to C++20 coroutines. It's limitations are it only supports one-shot
        resumptions.}
        \item{There are several Haskell libraries that implement effect handlers
\cite{DBLP:conf/haskell/XieL20, DBLP:conf/haskell/KiselyovI15,
DBLP:conf/haskell/WuSH14}. Some are discussed in more detail below.}
        \begin{itemize}
          \item{EvEff uses lambda calculus based evidence translation to
implement it's effects system. It provides deep effects.}
          \item{fused-effects
\footnote{https://hackage.haskell.org/package/fused-effects} fuses the effect
handlers it provides with computation by applying \emph{fusion laws} that avoid
intermediate representation. The handlers in fused-effects are one-shot
however.}
        \end{itemize}
\end{itemize}

\subsection{First-Class Effects}

\begin{itemize}
        \item{Unison is shown in more detail in section \ref{subsection:unison}}
        \item{Koka \cite{DBLP:journals/corr/Leijen14} is a statically typed
functional language with effect types and handlers. It can also compile
straight to C code without needing a garbage collector. Koka is developed by a
small team and as such is still missing much of its standard library.}
        \item{Frank \cite{DBLP:conf/popl/LindleyMM17} is a strict functional
language that is \emph{effectful} in that it has first class support for
bi-directional effects and effect handlers. }
        \item{Links \cite{DBLP:conf/fmco/CooperLWY06} is a functional
programming language designed for the web. Out of the box it does not support
true algebraic effects, however through an extension
\cite{DBLP:conf/icfp/HillerstromL16} it gains first class support for
continuations.}
\end{itemize}

\section{Shallow vs. Deep Effect Handlers}

There are two types of effect handler implementation, \emph{deep handlers}, as
originally defined by Plotkin and Pretnar \cite{plotkin2009handlers} and
\emph{shallow handlers} \cite{hillerstrom2018shallow}. Deep handlers pass a
copy of the full handler along with the computation which allows for the
handler to be invoked again as the handlers receive themselves as an argument.
Shallow handlers do not pass the handler with the computation. There are also
\emph{sheep handlers}, which while being shallow implement some of the
behaviour of deep handlers leading to the name sheep or shallow + deep. In
practice, the type of handler is more of an implementation detail although it
can have an effect on how code is structured.

\section{\textsc{UNIX}}

\textsc{Unix} \cite{ritchie1978unix} is an operating system designed and
implemented by Dennis M. Ritchie and Ken Thompson at AT\&T's Bell Labs in 1974.
It provides a file system (directories, file protection etc.), a shell,
processes (pipe, fork etc) and a userspace. Since it's first release it has been
reimplemented for a variety of systems.

\subsection{The UNIX Philosophy}

A phrase often associated with \textsc{Unix} is the \emph{Unix philosophy}.  The
\textsc{Unix} philosophy refers to some of the core principles with which it was
developed. The core principles involve composing many small simple programs that
accomplish one task well to solve more complex tasks \cite{raymond2003art}. The
idea of many small modular components has spread to many areas of computer
science including effect oriented programming.

\section{Effect Based File Systems}

Continuations in operating systems \cite{DBLP:conf/context/KiselyovS07}.

\section{Effect Handlers and UNIX}

In chapter 2 of his 2022 thesis, Daniel Hillerstr\"{o}m
\cite{hillerstrom2022foundations} outlines a theoretical implementation of UNIX
using the effects syntax outlined by Kammar et. al. \cite{kammar2013handlers}.
In this he provides an implementation of the original \textsc{Unix} paper
\cite{ritchie1978unix} that includes a filesystem and timesharing.
Hillerstr\"{o}m makes several assumptions about the effect system that would
need to be taken into account in order to implement this with a real language.
The main assumption is multi-shot handlers. For example the implementation of
\texttt{fork} uses multi-shot handlers to copy the full stack on both branches.
There are also some partial implementations such as \texttt{sed} \footnote{It is
worth mentioning \texttt{sed} has $20,000+$ lines of code} from which he only
implements string replacement.

\chapter{Base Implementation}

\section{Effect Oriented Programming in Unison}

As is shown in section \ref{subsection:unison}, effect oriented programming in
Unison is composed of an effect definition with an effect signature and a set
of effect operations and any handlers for that effect signature.

\section{Program Status}
\label{status}

In \texttt{Unix} programs must provide a code when they exit (usually 0 for
success and anything else for failure). To accomplish this we define a new effect
signature \texttt{Status} which provides the \texttt{exit} operation. The
\texttt{exit} operation takes one argument of type \texttt{Nat} \footnote{a
positive integer in Unison} and returns the unit type.

\begin{lstlisting}[language=unison]
unique ability Status
       where
            exit: Nat -> ()
\end{lstlisting}

\subsection{Unique vs. Structural Types}

In Unison, \texttt{unique} types are used when the name of the type is
semantically important. The alternative is \texttt{structural} types which are
used when the name of the type is not important and it can be stored as a hash
without it's name. We use \texttt{unique} types for most effect as this is not
a distributed application there is no need for \texttt{structural} types.

\subsection{The Handler}

The implementation for exit has no effect it simply consumes the exit code and
returns. The handler however returns a \texttt{Nat} return code. If an exit
operation is encountered we return the value given to the exit operation. The
return case simply returns 0 as if we reach the end of a function being handled
by the handler then we can assume it was successful and return 0.

\begin{lstlisting}[language=unison]
exitHandler : Request {e, Status} x -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> v
\end{lstlisting}

\subsection{The Request Type}

The \texttt{Request} type is a special type in Unison that allows for pattern
matching on operations of an effect. In the braces are the effect types for the
handler. The \texttt{Status} is the effect signature that is explicitly being
handled. The \texttt{e} allows for any other effects in the computation to be
passed through. The \texttt{x} is the return type of the computation.

\section{Basic I/O}
\label{io}

The \emph{effect signature} \texttt{BasicIO} is used for simple I/O operations.
The first and only \emph{effect operation} of \texttt{BasicIO} is \texttt{echo}
which takes an argument of type \texttt{Text} and returns the unit
type \texttt{()}. 

\begin{lstlisting}[language=unison]
unique ability BasicIO where
  echo: Text -> ()
\end{lstlisting}

The handler for \texttt{BasicIO} is simply a wrapper for Unison's
\texttt{putText} function which it uses to print the given text to
\texttt{stdout}. It then handles the resumption with the same handler to handle
any further \texttt{echo} calls.

\begin{lstlisting}[language=unison]
basicIO : Request {BasicIO} x ->{IO, Exception} ()
basicIO result =
    match result with
        { echo text -> resume } -> 
          putText stdOut text; 
          handle resume () with basicIO
        { result } -> ()
\end{lstlisting}

\subsection{IO and Exception abilities}

The handler for \texttt{BasicIO} uses the \texttt{putText} function from
Unison's standard library because of this we must include the \texttt{\{IO,
Exeption\}} in the type signature to indicate that this function needs access
to both the \texttt{IO} and \texttt{Exception} abilities in order to be run.
Both of these abilities are built in and used for all input and output in
unison.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]

\section*{Program 1 --- Hello World}

By combining the operations of Status and BasicIO we can write a simple program that prints ``Hello, World!" and then exits with the successful error code. Notice that the operations are invoked in the same way as functions. In this case they are being used inside a function. It would be possible to implement a simple shell for these commands however that is outside the scope of this project.

\begin{lstlisting}[language=unison]
greetAndExit : a ->{BasicIO, Status} ()
greetAndExit _ = echo "Hello, World!\n"; exit 0
\end{lstlisting}

By composing the two handlers in sections \ref{status} and \ref{io} we can run the program.

\begin{lstlisting}[language=unison]
runGreetAndExit _ = handle (handle !greetAndExit with basicIO) with exitHandler
\end{lstlisting}

By running this function with the unison codebase manager we get

\begin{lstlisting}[style=terminal]
Hello, World!

  0
\end{lstlisting}
\end{tcolorbox}

\section{Users and Environment}

To introduce the concept of a user-space and users we can start by adding some
hard coded users. For now, alice, bob and a root user: \texttt{unique type User
= Alice | Bob | Root}. To add generic users we could replace the definition with 
\texttt{unique type User = Text}, this would allow for the creation of new users.

Next we introduce the \texttt{Session} signature for operations involving
users. The operation \texttt{su} or \emph{substitute user} is used to change
the environment to that of a different user. The \texttt{ask} operation can be
used to access environment variables. Since the only variable we have now is
\texttt{USER} the argument to ask is a unit.

\begin{lstlisting}[language=unison]
unique ability Session
    where
        su: User -> {Session } ()
        ask: () -> {Session } Text
\end{lstlisting}

We can now implement the \textsc{Unix} command \texttt{whoami} with a wrapper
around ask.

\begin{lstlisting}[language=unison]
whoami: '{Session} Text
whoami _ = ask ()
\end{lstlisting}

\subsection{The Apostrophe in Unison}

The \texttt{'} character in Unison is syntactic sugar for a function with a
unit as the type of it's first argument. For example, the type signature of 
\texttt{whoami} could be rewritten as \texttt{() ->\{Session\} Text}. This is 
equivalent to \texttt{'\{Session\} Text}.

\subsection{Environment as a handler}

The handler for \texttt{Session} also takes a user as an argument, this is the
user that is currently logged in. To switch user we simply handle the rest of
the computation with the new user provided as the argument to \texttt{su}. Then
when the computation ends we will be back in the environment of the old user.

Due to the single environment variable being \texttt{USER}, \texttt{ask}
performs the action of \texttt{whoami}. It keeps the user the same and returns
the user as a string.

\begin{lstlisting}[language=unison]
env: User -> Request {Session} a -> a
env user request = 
    match request with
        {result} -> result
        { ask () -> resume } -> match user with 
            Alice -> handle resume "alice" with env user
            Bob -> handle resume "bob" with env user
            Root -> handle resume "root" with env user
        {su user' -> resume} -> handle resume () with env user'
\end{lstlisting}

In this way the environment is the handler itself as it contains the information such as which user is logged in. The handler can be extended to have parameterised environment variables making it the complete environment.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 2 --- Session Management}

  \begin{lstlisting}[language=unison]
    session _ = su Alice
                echo (!whoami)
                echo "\n"
                su Bob
                echo (!whoami)
                echo "\n"
                su Root
                echo(!whoami)
                echo "\n"
  \end{lstlisting}


  \begin{lstlisting}[style=terminal]
    alice
    bob
    root
      
      ()
\end{lstlisting}
\end{tcolorbox}


\section{Nondeterminism}

\begin{lstlisting}[language=unison]
unique type PState a e = Done a | Paused ('{e} PState a e)
\end{lstlisting}


\begin{lstlisting}[language=unison]
unique ability Interrupt
    where
        interrupt: {Interrupt } ()

unique ability TimeSharing
    where
        fork: {TimeSharing } Boolean
\end{lstlisting}

\section{Serial File System}

\section{Pipes}

\section{Unix Fork}

\chapter{Extensions}

\chapter{Evaluation}

\chapter{Conclusion}

\bibliographystyle{unsrt}
\bibliography{diss}

\end{document}
