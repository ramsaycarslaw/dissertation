\documentclass[logo,bsc,singlespacing,parskip]{infthesis}

\usepackage{ugcheck}

\usepackage{microtype}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{subcaption}
\usepackage{booktabs}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{gray}{HTML}{666666}		%#666666
\definecolor{lightbule}{HTML}{006699}		%#006699
\definecolor{lightgreen}{HTML}{669900}		%#669900
\definecolor{bluegreen}{HTML}{33997e}		%#33997e
\definecolor{magenta}{HTML}{d94a7a}		%#d94a7a
\definecolor{orange}{HTML}{e2661a}		%#e2661a
\definecolor{purple}{HTML}{7d4793}		%#7d4793
\definecolor{green}{HTML}{718a62}		%#718a62

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=none,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstdefinelanguage{unison}{
  %keyword1&2&6
  morekeywords = [1]{ability, type, handle, with, if, then, else, match, cases, let},
  %keyword3
  morekeywords = [2]{unique, structural},
  %keyword4
  morekeywords = [3]{Status, BasicIO, User, Environment, Session, PState, Done, Paused, Interrupt, TimeSharing, Alice, Bob, Root, State, FileSystem, FileSystemT, FileRW, FileCO, FileLU, INode, INodeT, IList, IListT, DataRegion, DataRegionT, Directory, DirectoryT, Yield, Await},
  %keyword5
  morekeywords = [4]{Nat, Text, List, Tuple, (), Request, Boolean, IO, Exception},
  keywordstyle = [1]\color{bluegreen},
  keywordstyle = [2]\color{lightgreen},
  keywordstyle = [3]\color{codepurple},
  keywordstyle = [4]\color{orange},
  sensitive = true,
  morecomment = [l]{--},
  morecomment = [s]{\{-}{-\}},
  commentstyle = \color{gray},
  morestring = [b]",
  stringstyle = \color{purple}
}

\lstdefinestyle{terminal}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  captionpos=b,
  xleftmargin=10pt,
  numbers=none,
}

\lstset{style=mystyle}


\begin{document}
\begin{preliminary}

\title{Implementing UNIX with Effects Handlers}
\author{Ramsay Carslaw}

\course{Computer Science}
\project{4th Year Project Report}

\date{\today}

% https://okmij.org/ftp/continuations/ZFS/context-OS.pdf
% https://dl.acm.org/doi/pdf/10.1145/800087.802786

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}

\begin{acknowledgements}
  Any acknowledgements go here.
\end{acknowledgements}

\tableofcontents

\end{preliminary}

\part{Project}

\chapter{Introduction}

\section{Motivation}

Effect handlers \cite{plotkin2002computational} are widely becoming adopted in
functional programming languages \cite{DBLP:journals/corr/Leijen14} and even
imperative languages as libraries. They provide a unique and expressive syntax
for handling side effects and control flow. This has led to a new paradigm of
programming known as \emph{effect-oriented programming}
\cite{pretnar2015introduction}. Effect-oriented programming leverages the way
effect handlers can be composed to create modular programs that can be easily
extended and maintained. The aim of this project is to demonstrate that complex
programs, such as \emph{Unix} \cite{ritchie1978unix} can be implemented in this
effect oriented style. The project details techniques and observations on
effect oriented programming through the context of implementing a Unix-like
operating system.

We choose to implement Unix as it is a well known and widely used operating
system. Choosing an operating system also introduces more advanced control flow
and concepts through time sharing, filesystems and pipes. The primary
implementation language of this project is \emph{Unison}, a functional
programming language with first class support for effect handlers.

\section{Aims}

While the primary goal is to implement a Unix-like operating system in Unison,
the project also aims to compare the effect oriented programming style to
traditional programming styles. The project will also aim to provide a
commentary on the performance of effect handlers in Unison. The goal is not to
write a real operating system but to demonstrate that effect handlers can be
the right choice for complex programming tasks. 

\section{Objectives}

The objectives of the project are as follows:

\begin{itemize}
  \item{Provide a background and context for effect oriented programming and it's intersection with operating systems}
  \item{Implement a Unix-like operating system in Unison based on the work of Hillerstr\"{o}m \cite{hillerstrom2022foundations}}
  \item{Extend this initial version with more interesting uses of effect handlers and more advanced operating system features}
  \item{Provide a commentary on the performance of effect handlers in Unison}
  \item{Compare the effect oriented programming style to traditional programming styles}
  \item{Provide a reflection on the project and it's outcomes}
\end{itemize}

\section{Outline}

Chapter 2 introduces the literature and background of effect handlers and
provides a simple example in Unison. We then discuss the state of effect
oriented programming and some of the pros and cons of various effect
implementations. Chapter 2 also describes some of the other research that has
been done in this area.

Chapter 3 details the Unison implementation of a Hillerstr\"{o}m's toy Unix
operating system. It provides a basic implementation of a subset of Unix
features including: users, a filesystem , timesharing and pipes. This chapter
also provides examples on using the implemented features.

Chapter 4 outlines features implemented beyond Hillerstr\"{o}m's original
implementation. This includes a more advanced scheduler, errors and exceptions
as well as an overhauled userspace complete with environment variables.

Chapter 5 provides a commentary on the performance of effect handlers in Unison
and details some of the challenges faced when implementing Unix in this way.
It also compares the effect oriented programming style to traditional
programming styles in areas such as modularity, extensibility and performance.

Chapter 6 provides a reflection on the project and it's outcomes. It details
some of the challenges faced and the lessons learned. It also provides some
ideas for future work in this area.

\chapter{Background}

\section{Algebraic Effects and Effect Handlers}

Algebraic effects \cite{plotkin2002computational} and their corresponding
handlers \cite{plotkin2009handlers} \cite{pretnar2015introduction} are a
programming paradigm that when paired together offers a novel way to compose
programs. It starts with the definition of the effect or the \emph{effect
signature} that gives the effect a name in scope and specifies any input and the
return type otherwise known as the \emph{effect operation}.  For example, we
might define the effect signature \emph{State} that stores state for some type
\texttt{a}. In order to make use of our \emph{State} effect we can define the
effect operations \emph{put} and \emph{get} where put will update the value of
type \texttt{a} stored in state and get will return the current value.  At this
stage the effect operation has no implementation and is more an acknowledgement
to the compiler that it should expect an implementation. For this reason any
function that references these effect operations is known as an \emph{effectful
function} or a function whose definition is not complete without an effect
handler. In the put and get example, any function that uses put and get to store
values would be an effectful function. The \emph{effect handler} provides one
implementation of the given effect operation. We could define a simple handler
for state that simply updates a variable of the given type or we could define a
more complex one that uses hash maps.  In this way, we can change the semantics
of an effectful function by handling it with a different handler that provides
an alternative implementation to the effect. Crucially, we can have multiple
handlers defined in the same program for one effect allowing for much more
modular programming or \emph{effect-oreinted programming}.

When are programs rely on input from the real world like connecting to a server
on the internet or getting input from a user, it is no longer safe to assume
this input will be passed as we expect. For example, the server could time out
or not be at the address the program is expecting it to be at or the user could
enter a string that is too long for the input. These real world uncertainties
are known as \emph{Side Effects}. Effect handlers can be used to provide
alternate implementations of functions that may have side effects and allow for
control flow with these effects.

\subsection{Example in Unison}
\label{subsection:unison}

Unison \footnote{https://github.com/unisonweb/unison} is a
functional language implemented in Haskell that offers built in support for effect
handlers through it's abilities system.

Unison provides the \emph{ability} keyword which allows users to define their own
effects. It also provides the \emph{handle ... with ...} pattern to attach handlers to effectful functions.

\begin{lstlisting}[caption={The \emph{put} and \emph{store} example in Unison. Note that the \emph{structural} keyword refers to the fact that Unison stores type definitions as a hash. Even if we changed all the variable names it would still view it as the same type. To avoid that behaviour you can swap the \emph{structural} keyword for \emph{unique}}]
structural ability Store a where
  put: a -> {Store a} ()
  get: {Store a} a
\end{lstlisting}

This defines the two effect operations \texttt{put} and \texttt{get} that have
the effect signature \texttt{Store a}. Put takes a value of type \texttt{a} and
returns the unit type \texttt{()}. The prefix of \texttt{\{Store a\}} to the
\texttt{()}, refers to the fact that in order to allow for \texttt{put} to
return, it must be run from an effectful function that is handled with an
appropriate handler for \texttt{Store a}. Similarly, \texttt{put} takes an
argument of type \texttt{a} and must be handled.

\begin{lstlisting}[language=unison, caption={An example of an effectful function that uses the \texttt{Store} effect}]
addStore : a -> {Store a} ()
addStore x =
  y = get
  put (x + y)
\end{lstlisting}
\label{listing:addstore}

The code in listing \ref{listing:addstore} is an example of how you would use
the effects in Unison. It takes an argument of type \texttt{a} and `adds' it to
the current value by using \texttt{get}. Note that in order for this to work the
infix operation `+' must be implemented for type \texttt{a}. Now we only need to
define the handler.

\begin{lstlisting}[caption={The handler for the \texttt{Store} effect}]
    storeHandler : a -> Request (Store a) a -> a
    storeHandler value = cases
        {Store.get -> resume} -> handle resume value with storeHandler value
        {Store.put v -> resume} handle resume () with storeHandler v
        {result} -> result

\end{lstlisting}

The handlers in Unison use tail recursion to reduce to the case where just the
value is left \texttt{result -> result}. For both store and put we use the
resumption and the handler to reach the final value. The special type
\texttt{Request} allows us to perform pattern matching on the possible types of
the computation.

\begin{lstlisting}
handle (addStore 10) with storeHandler 10
\end{lstlisting}

Finally, we can put it all together by calling the function \texttt{addStore}
with the handler \texttt{storeHandler}. 

\section{Affine and `Multi-Shot' Handlers}

If remaining computation or continuation of an effect can be resumed once from
a handler then the effect system implements \emph{one-shot} or \emph{affine}
effect handlers. If it is able to resume the computation multiple times then it
is a \emph{multi-shot} handler. 

\section{The State of Effect-Oriented Programming}

\subsection{Library Based Effects}

\begin{itemize}
        \item{libhandler \cite{leijen2017implementing} is a portable c99 library
that implements algebraic effect handlers for C. It implements high performance
multi-shot effects using standard C functions. It is limited by the assumptions
it makes about the stack such as it being contiguous and not moving. In practice
this could lead to memory leaks if it copies pointers.}
        \item{libmprompt \footnote{https://github.com/koka-lang/libmprompt} is a
C/C++ library that adds effect handlers. It uses virtual memory to solve the
problem mentioned with libhandler. By keeping the stack in a fixed location in
virtual memory it restores safety. It also provides the higher level libmpeff
interface. A downside is they recommend at least 2GiB of virtual memory to
allow for 16000 stacks which may be challenging on some systems.}
        \item{cpp-effects \cite{DBLP:journals/pacmpl/GhicaLBP22} is a C++
implementation of effect handlers. It uses C++ template classes and types to
create modular effects and handlers. It's performance has been shown to be
comparable to C++20 coroutines. It's limitations are it only supports one-shot
        resumptions.}
        \item{There are several Haskell libraries that implement effect handlers
\cite{DBLP:conf/haskell/XieL20, DBLP:conf/haskell/KiselyovI15,
DBLP:conf/haskell/WuSH14}. Some are discussed in more detail below.}
        \begin{itemize}
          \item{EvEff uses lambda calculus based evidence translation to
implement it's effects system. It provides deep effects.}
          \item{fused-effects
\footnote{https://hackage.haskell.org/package/fused-effects} fuses the effect
handlers it provides with computation by applying \emph{fusion laws} that avoid
intermediate representation. The handlers in fused-effects are one-shot
however.}
        \end{itemize}
\end{itemize}

\subsection{First-Class Effects}

\begin{itemize}
        \item{Unison is shown in more detail in section \ref{subsection:unison}}
        \item{Koka \cite{DBLP:journals/corr/Leijen14} is a statically typed
functional language with effect types and handlers. It can also compile
straight to C code without needing a garbage collector. Koka is developed by a
small team and as such is still missing much of its standard library.}
        \item{Frank \cite{DBLP:conf/popl/LindleyMM17} is a strict functional
language that is \emph{effectful} in that it has first class support for
bi-directional effects and effect handlers. }
        \item{Links \cite{DBLP:conf/fmco/CooperLWY06} is a functional
programming language designed for the web. Out of the box it does not support
true algebraic effects, however through an extension
\cite{DBLP:conf/icfp/HillerstromL16} it gains first class support for
continuations.}
\end{itemize}

\section{Shallow vs. Deep Effect Handlers}

There are two types of effect handler implementation, \emph{deep handlers}, as
originally defined by Plotkin and Pretnar \cite{plotkin2009handlers} and
\emph{shallow handlers} \cite{hillerstrom2018shallow}. Deep handlers pass a
copy of the full handler along with the computation which allows for the
handler to be invoked again as the handlers receive themselves as an argument.
Shallow handlers do not pass the handler with the computation. There are also
\emph{sheep handlers}, which while being shallow implement some of the
behaviour of deep handlers leading to the name sheep or shallow + deep. In
practice, the type of handler is more of an implementation detail although it
can have an effect on how code is structured.

\section{\textsc{UNIX}}

\textsc{Unix} \cite{ritchie1978unix} is an operating system designed and
implemented by Dennis M. Ritchie and Ken Thompson at AT\&T's Bell Labs in 1974.
It provides a file system (directories, file protection etc.), a shell,
processes (pipe, fork etc) and a userspace. Since it's first release it has been
reimplemented for a variety of systems.

\subsection{The UNIX Philosophy}

A phrase often associated with \textsc{Unix} is the \emph{Unix philosophy}.  The
\textsc{Unix} philosophy refers to some of the core principles with which it was
developed. The core principles involve composing many small simple programs that
accomplish one task well to solve more complex tasks \cite{raymond2003art}. The
idea of many small modular components has spread to many areas of computer
science including effect oriented programming.

\section{Effect Based File Systems}

Continuations in operating systems \cite{DBLP:conf/context/KiselyovS07} are not
a new concept.  Kiselyov has demonstrated that algebraic effects can be used in
a real file system and provide advanced features like snapshots, an undo
operation and copy-on-write behaviour. Although this publication does not
consider the performace of implementing features in this way it demonstrates that
file systems can be built around continuations.

\section{Effect Handlers and UNIX}

In chapter 2 of his 2022 thesis, Daniel Hillerstr\"{o}m
\cite{hillerstrom2022foundations} outlines a theoretical implementation of UNIX
using the effects syntax outlined by Kammar et. al. \cite{kammar2013handlers}.
In this he provides an implementation of the original \textsc{Unix} paper
\cite{ritchie1978unix} that includes a filesystem and timesharing.
Hillerstr\"{o}m makes several assumptions about the effect system that would
need to be taken into account in order to implement this with a real language.
The main assumption is multi-shot handlers. For example the implementation of
\texttt{fork} uses multi-shot handlers to copy the full stack on both branches.
There are also some partial implementations such as \texttt{sed} \footnote{It is
worth mentioning \texttt{sed} has $20,000+$ lines of code} from which he only
implements string replacement.

\chapter{Base Implementation}
\label{baseimplementation}

\section{A Basic UNIX Implementation}

This chapter outlines and details a Unison implementation of the toy
\textsc{Unix} written by Hillerstr\"{o}m \cite{hillerstrom2022foundations}.
Hillerstr\"{o}m's original is written in a fictional Lambda calculus that allows
for using Shallow, Deep and Parameterised handlers. in the Unison implemenation
I use only shallow handlers.

\section{Program Status}
\label{status}

In \texttt{Unix} programs must provide a code when they exit (usually 0 for
success and anything else for failure). The effect signature \texttt{Status}
provides the \texttt{exit} operation which takes one argument of type
\texttt{Nat} \footnote{a positive integer in Unison} and returns the empty type
which is defined \texttt{unique type Empty =}. The argument represents the
return code.

\begin{lstlisting}[language=unison]
unique ability Status
       where
            exit: Nat -> Empty
\end{lstlisting}

We can now use this to indicate program status. For example:

\begin{lstlisting}[language=unison]
  --- some functionality 

  if somethingWentWrong == true then
    exit 1
  else
    print "Hello, World"
\end{lstlisting}

There is no explicit exit 0 on the else branch. This is because the default
state of a program should be 0, it should not need an explicit \texttt{exit 0}.

\subsection{Unique vs. Structural Types}

In Unison, \texttt{unique} types are used when the name of the type is
semantically important. The alternative is \texttt{structural} types which are
used when the name of the type is not important and it can be stored as a hash
without it's name. \texttt{unique} types are used for all effects as it has no
real implication given the program is not distributed.

\subsection{The Handler}

The handler for \texttt{Status} is defined as:

\begin{lstlisting}[language=unison]
exitHandler : Request {e, Status} x -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> abort
\end{lstlisting}

The implementation for exit has no effect it simply consumes the exit code and
returns. The handler however returns a \texttt{Nat} return code. If an exit
operation is encountered we return the value given to the exit operation. The
return case simply returns 0 as if we reach the end of a function being handled
by the handler then we can assume it was successful and return 0.


\subsection{The Request Type}

The \texttt{Request} type is a special type in Unison that allows for pattern
matching on operations of an effect. In the braces are the effect types for the
handler. The \texttt{Status} is the effect signature that is explicitly being
handled. The \texttt{e} allows for any other effects in the computation to be
passed through. The \texttt{x} is the return type of the computation.

\section{Basic I/O}
\label{io}

The \emph{effect signature} \texttt{BasicIO} is used for simple I/O operations.
The first and only \emph{effect operation} of \texttt{BasicIO} is \texttt{echo}
which takes an argument of type \texttt{Text} and returns the unit
type \texttt{()}. 

\begin{lstlisting}[language=unison]
unique ability BasicIO where
  echo: Text -> ()
\end{lstlisting}

The handler for \texttt{BasicIO} is simply a wrapper for Unison's
\texttt{putText} function which it uses to print the given text to
\texttt{stdout}. It then handles the resumption with the same handler to handle
any further \texttt{echo} calls.

\begin{lstlisting}[language=unison]
basicIO : Request {BasicIO} x ->{IO, Exception} ()
basicIO result =
    match result with
        { echo text -> resume } -> 
          putText stdOut text; 
          handle resume () with basicIO
        { result } -> ()
\end{lstlisting}

\subsection{IO and Exception abilities}

The handler for \texttt{BasicIO} uses the \texttt{putText} function from
Unison's standard library because of this we must include the \texttt{\{IO,
Exeption\}} in the type signature to indicate that this function needs access
to both the \texttt{IO} and \texttt{Exception} abilities in order to be run.
Both of these abilities are built in and used for all input and output in
unison.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]

\section*{Program 1 --- Hello World}
\label{prog:helloworld}

By combining the operations of Status and BasicIO we can write a simple program that prints ``Hello, World!" and then exits with the successful error code. Notice that the operations are invoked in the same way as functions. In this case they are being used inside a function. It would be possible to implement a simple shell for these commands however that is outside the scope of this project.

\begin{lstlisting}[language=unison]
greetAndExit : a ->{BasicIO, Status} ()
greetAndExit _ = echo "Hello, World!\n"; exit 0
\end{lstlisting}

By composing the two handlers in sections \ref{status} and \ref{io} we can run the program.

\begin{lstlisting}[language=unison]
runGreetAndExit _ = handle (handle !greetAndExit with basicIO) with exitHandler
\end{lstlisting}

By running this function with the unison codebase manager we get

\begin{lstlisting}[style=terminal]
Hello, World!

  0
\end{lstlisting}
\end{tcolorbox}

\subsection{Defining Multiple Handlers}

Effects are not limited to just one handler. The semantics of echo can be
changed without altering it's definition. For example, the \texttt{backwardsIO}
handler below.

\begin{lstlisting}[language=unison]
backwardsIO : Request {BasicIO} x ->{IO, Exception} () 
backwardsIO result =
  match result with
  { echo text -> resume } -> 
    handle resume () with basicIO 
    putText stdOut text;
  { result } -> ()
\end{lstlisting}

In this case, the resumption is handled first and then the text is printed. The
effect of this is best shown by running it side by side with \texttt{basicIO}
on the following program.

\begin{lstlisting}[language=unison]
helloworld _ = echo "Hello,"; echo " World!\\n"
\end{lstlisting}

The output of running this program with each handler is shown in Figure \ref{fig:sidebyside}.

\begin{figure}[h]
  \label{fig:sidebyside}
\begin{minipage}{0.5\textwidth}

\begin{lstlisting}[style=terminal]
> handle !helloworld with basicIO

Hello, World!

  ()
\end{lstlisting}

\end{minipage}%
\begin{minipage}{0.5\textwidth}

\begin{lstlisting}[style=terminal]
 > handle !helloworld with backwardsIO

 World!
Hello,
  ()
\end{lstlisting}
\end{minipage}
\caption{The output of running \texttt{helloworld} with each handler.}
\end{figure}

\section{A Unix Function}

When we start composing handlers like in Program \hyperref[prog:helloworld]{1}
the \texttt{handle (handle (...) with ... ) with ...)} syntax can start to get
verbose. To solve this we will introduce one \textsc{Unix} function where we
compose all the handlers that takes a function using the operations we have
defined as an argument.

\begin{lstlisting}[language=unison]
unix : (() ->{e, BasicIO, Status} a) ->{e, IO, Exception} Nat
unix prog = handle (handle !prog with basicIO) with exitHandler
\end{lstlisting}

We accept a function as an argument that needs both \texttt{Status} and
\texttt{BasicIO} to be handled in order to be run. We then apply the handlers
to the function and run it. We handle status last as this gives us \texttt{Nat}
as a return code which the whole function can return. We can now run
\texttt{unix helloworld} to get the following:

\begin{lstlisting}[language=unison]
  Hello, World!

    0
\end{lstlisting}

We now get the 0 return code as the result of the computation, indicating it was successful.

\section{Users and Environment}
\label{userspace}

To introduce the concept of a user-space and users we can start by adding some
hard coded users. For now, alice, bob and a root user: \texttt{unique type User
= Alice | Bob | Root}.

Next we introduce the \texttt{Session} signature for operations involving
users. The operation \texttt{su} or \emph{substitute user} is used to change
the environment to that of a different user. The \texttt{ask} operation can be
used to access environment variables. Since the only variable we have now is
\texttt{USER} the argument to ask is a unit.

\begin{lstlisting}[language=unison]
unique ability Session
    where
        su: User -> {Session } ()
        ask: () -> {Session } Text
\end{lstlisting}

We can now implement the \textsc{Unix} command \texttt{whoami} with a wrapper
around ask.

\begin{lstlisting}[language=unison]
whoami: '{Session} Text
whoami _ = ask ()
\end{lstlisting}

We now have all the tools to keep track of which user is logged in and display
that information:

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 2 --- Session Management}
  
  We can now compose the handlers we have written so far to switch between the
  users and invoke \texttt{whoami}.

  \begin{lstlisting}[language=unison]
    session _ = su Alice
                echo (!whoami)
                echo "\n"
                su Bob
                echo (!whoami)
                echo "\n"
                su Root
                echo(!whoami)
                echo "\n"
  \end{lstlisting}

  The function \texttt{runsession} simply invokes \texttt{session} using our
  \texttt{unix} function.

  \begin{lstlisting}[language=unison]
    runsession _ = unix session
  \end{lstlisting}

  \begin{lstlisting}[style=terminal]
    alice
    bob
    root
      
      0
\end{lstlisting}
\end{tcolorbox}

\subsection{The Apostrophe in Unison}

The \texttt{'} character in Unison is syntactic sugar for a function with a
unit as the type of it's first argument. For example, the type signature of 
\texttt{whoami} could be rewritten as \texttt{() ->\{Session\} Text}. This is 
equivalent to \texttt{'\{Session\} Text}.

\subsection{Environment as a handler}

The handler for \texttt{Session} also takes a user as an argument, this is the
user that is currently logged in. To switch user we simply handle the rest of
the computation with the new user provided as the argument to \texttt{su}. Then
when the computation ends we will be back in the environment of the old user.

Due to the single environment variable being \texttt{USER}, \texttt{ask}
performs the action of \texttt{whoami}. It keeps the user the same and returns
the user as a string.

\begin{lstlisting}[language=unison]
env: User -> Request {Session} a -> a
env user request = 
    match request with
        {result} -> result
        { ask () -> resume } -> match user with 
            Alice -> handle resume "alice" with env user
            Bob -> handle resume "bob" with env user
            Root -> handle resume "root" with env user
        {su user' -> resume} -> handle resume () with env user'
\end{lstlisting}

In this way the environment is the handler itself as it contains the
information such as which user is logged in. The handler can be extended to
have parameterised environment variables making it the complete environment.

\subsection{Adding the Handler to the Unix Function}

Given the \texttt{unix} function represents the initial state of the system we
choose the root user to be logged in by passing it as an argument to the
handler as well as composing it with the other two.

\begin{lstlisting}[language=unison]
unix : '{e, Session, BasicIO, Status} a ->{e, IO, Exception} Nat
unix prog = handle (handle (handle !prog with basicIO) with env Root) with exitHandler
\end{lstlisting}

We still leave the \texttt{exitHandler} on the outside to get the return code.

\section{Nondeterminism}

To implement the \texttt{fork} command from \textsc{Unix} we can leverage
deliberate non-determinism that is possible with effect handlers. We define the
\texttt{fork} operation which returns a \texttt{Boolean} as a member of the
\texttt{TimeSharing} signature.

\begin{lstlisting}[language=unison]
unique ability TimeSharing
    where
        fork: Boolean
\end{lstlisting}

To use \texttt{fork} we can simply use it in control flow to create a branch.
Where normally only one branch would be executed, the two branches become our
two processes. For example:

\begin{lstlisting}[language=unison]
if fork then 
  echo "Heads\n"
else 
  echo "Tails\n"
\end{lstlisting}

By running that code with the \texttt{unix} function we get:

\begin{lstlisting}[style=terminal]
  Heads
  Tails
    
    0
\end{lstlisting}

The handler for fork is also fairly simple:

\begin{lstlisting}[language=unison]
nondet : Request {TimeSharing} a -> [a]
nondet request =
    match request with
        { fork -> resume } -> (handle resume true with nondet) lib.base.data.List.++ (handle resume false with nondet)
        { result } -> [result]
\end{lstlisting}

The handler returns a list of values with the type \texttt{a} which is the
return type of the computation. When we encounter a \texttt{fork} we resume
with the values true and false and join the two lists that are created. The
return case wraps the value in a list so that we can use the \texttt{++}
operator.

\subsection{Joining Lists in Unison}

Unison's typechecker sometimes struggles inferring the type of \texttt{++}. For
this reason we include the full path to the standard library where \texttt{++}
is defined i.e. \texttt{lib.base.data.List.++}.

\section{Scheduling}

Now that we can create processes through \texttt{fork} it would be useful to be able to write scheduling algorithms. Currently \texttt{fork} will run the first process to completion, and then run the second process to completion. To begin scheduling we need to give the processes a method of stopping execution and giving control to the other process. We introduce the \texttt{Interrupt} signature with one operation also called \texttt{interrupt}.

\begin{lstlisting}[language=unison]
unique ability Interrupt
    where
        interrupt: {Interrupt } ()
\end{lstlisting}

Now that we have \texttt{interrupt} we can write an alternative handler for
\texttt{BasicIO} that will \texttt{interrupt} before every IO operation,
allowing for the other process to run first.

\begin{lstlisting}[language=unison]
interruptWrite : Request {e, BasicIO} x ->{e, Interrupt, BasicIO} ()
interruptWrite result =
    match result with
        { echo text -> resume } -> 
            interrupt
            echo text 
            handle resume () with interruptWrite
        { result } -> ()
\end{lstlisting}

Note that we still need to provide a handler for \texttt{echo}, this handler
simply injects interrupt in front of every instance of \texttt{echo}.

In order to schedule processes we need to introduce state. Each process can either be \texttt{Done} (It has produced a return value) or \texttt{Paused} (It has been interrupted). \texttt{Paused} is a recursive definition as it contains a \texttt{PState} in it's type.

\begin{lstlisting}[language=unison]
unique type PState a e = Done a | Paused ('{e} PState a e)
\end{lstlisting}

The type \texttt{a} is the return type of the process and the \texttt{e} is an
effect variable that represents any effects that are needed to run the
\texttt{PState}. This can be thought of as analagous to the \emph{resumption
monad} first introduced by Milner in 1975 \cite{MILNER1975157}, in that
computation is split into either the result or another computation i.e. the
resumption. We can now implement the handler for \texttt{interrupt}.

\begin{lstlisting}[language=unison]
reifyProcess : Request {Interrupt, e} a -> PState a e
reifyProcess request =
    match request with
        { interrupt -> resume } -> Paused (_ -> handle !resume with reifyProcess )
        { result } -> Done result
\end{lstlisting}

In the case of an interrupt, the handler suspends the computation by making it
an anonymous function with a unit type as it's first argument, and wrapping it
in the paused datatype. This means we can run the \texttt{Paused} computations
later by invoking that function we created. The return case simply wraps the
value in the \texttt{Done} type. 

\begin{lstlisting}[language=unison]
sched : [PState a {e, TimeSharing}] -> [a] ->{e} [a]
sched ps done = 
    match ps with
        [] -> done
        (Done res) +: ps' -> sched ps' (res lib.base.data.List.+: done)
        (Paused m) +: ps' -> sched (ps' lib.base.data.List.++ (handle !m with nondet)) done

timeshare : '{g, Interrupt, TimeSharing} o ->{g} [o]
timeshare m = sched [Paused (_ -> handle !m with reifyProcess)] []
\end{lstlisting}

\section{Serial File System}
\label{sec:filesystem}

\subsection{State}

To implement a file system we need to introduce a method of storing and
retrieving state. The effect signature and operations introduced in section
\ref{subsection:unison} provide the perfect interface as it takes a generic
type \texttt{a} as an argument, we can introduce our own type to represent the
filesystem and use it as an argument to \texttt{State}.

\subsection{Definitions}

\textbf{File System} ---
Unlike a real \textsc{Unix} implementation we only implement the most basic
operations on files, i.e. creation, deletion, reading and writing. Additionally
we treat everything as a file, unlike \textsc{Unix} which has directories and
special files, we only allow basic files. Thus the file tree is completely flat.

\textbf{Serial} --- Each file can only be read from in order, additionally when
we write to file, there are no write modes, we only append to the file.
Semantically, different write modes can be achieved with the four basic
operations and can be implemented by composing handlers. For example,
overwriting a file is equivalent to deleting the existing file, creating a new
one with the same name and writing the content to the new file.

\subsection{Types}
\label{sec:filesystemtypes}

\begin{lstlisting}[language=unison]
unique type DirectoryT = Directory (Text, Nat)
unique type DataRegionT = DataRegion (Nat, Text)
unique type INodeT = INode Nat Nat
unique type IListT = IList (Nat, INodeT)
unique type FileSystemT = FileSystem (List DirectoryT) (List IListT) (List DataRegionT) Nat Nat
\end{lstlisting}

\begin{itemize}
  \item{\texttt{DirectoryT} --- A directory stores a file name with it's associated I-number}
  \item{\texttt{INode} --- An I-Node stores the metadata for a file along with a pointer to a \texttt{DataRegion}}
  \item{\texttt{IList} --- An I-List stores an I-number with an I-Node}
  \item{\texttt{DataRegion} --- A DataRegion contains the actual file contents along with the pointer from the \texttt{INode}}
\end{itemize}

Finally, the \texttt{FileSystem} type collects the above types into lists along with two \texttt{Nat}'s to represent the next directory number and the next I-number.

\subsection{Initial File System}

Much like \texttt{Root} is the initial user, we introduce an initial file
system by initialising the types in section \ref{sec:filesystemtypes}. We
create the file \texttt{stdout} to represent the standard output file at
I-number 0.

\begin{lstlisting}[language=unison]
initialINode : INodeT
initialINode = INode 0 0

initialDirectory : DirectoryT
initialDirectory = (Directory ("stdout", 0))


initialDataRegion : DataRegionT
initialDataRegion = DataRegion (0, "")

initialIList : IListT
initialIList = IList (0, initialINode)

initialFileSystem : FileSystemT
initialFileSystem = FileSystem [initialDirectory] [initialIList] [initialDataRegion] 0 0
\end{lstlisting}

\subsection{Effect Types and Operations}

Now we have the types and the state we can introduce the new effect signatures
and operations. Firstly, \texttt{FileRW} which provides the \texttt{read} and
\texttt{write}.

\begin{lstlisting}[language=unison]
unique ability FileRW
  where
      read: Nat -> Text
      write: (Nat, Text) -> ()
\end{lstlisting}

\textbf{read} --- Read takes an I-number and returns the text at the corresponding data region.

\textbf{write} -- Write takes an I-number and some text and appends the text to
the end of the data region pointed to by the I-number.

Next \texttt{FileCO} which is used for creating and opening files.
\begin{lstlisting}[language=unison]
unique ability FileCO
  where
      create: Text -> Nat
      open: Text -> Nat
\end{lstlisting}
\texttt{FileCO} provides two operations, \texttt{create} and \texttt{open}.

\textbf{create} --- Create takes a filename and returns a fresh I-number for
the new file. If the provided filename exists it will overwrite the file to be
blank again.

\textbf{open} --- Open takes a filename and returns the I-number associated with it.

Finally, we have \texttt{FileLU} which links and unlinks files.

\begin{lstlisting}[language=unison]
unique ability FileLU
    where
        link: (Text, Text) -> ()
        unlink: Text -> ()
\end{lstlisting}


\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 3 -- \texttt{mv}}

  We can now use these effect operations to define a \texttt{mv} command. While
  it can be used to move files between directories we have a flat file system
  so in this case it's more of a rename command.

  \begin{lstlisting}[language=unison]

mv : Text -> Text ->{State FileSystemT, FileRW, FileCO} ()
mv src dest = 
    let file = read (open src)
        _ = create src
        write ((create dest), file)

  \end{lstlisting}

  First we use open to obtain the I-number of of the \texttt{INode} of the
  source file, we can then use this I-number as an argument to \texttt{read} to
  obtain the contents of the source file. Now that the contents of the source
  file are stored in the \texttt{file} varaible, we can safely delete the
  source file by calling \texttt{create} on it. If \texttt{create} is called on
  an existing file it will delete that file by overwriting it. Since we no
  longer need it's I-number we assign the return value of the \texttt{create}
  to an empty variable. Finally, in one step we create the destination file
  (overwriting it if it exists) and write the value of the variable
  \texttt{file} to this new file using the I-number returned from
  \texttt{create}.

\end{tcolorbox}

\subsection{File System Handlers}

The handler for \texttt{FileRW} is fairly simple. It takes a request and
matches on the operations. If the operation is \texttt{read} it returns the
text at the corresponding data region. If the operation is \texttt{write} it
appends the text to the end of the data region pointed to by the I-number.
It makes use of the underlying \texttt{fwrite} and \texttt{fread} functions
that traverse the filesystem data structure, they are listed in the appendix.
It will silently fail currently which we will address in the next chapter.

\begin{lstlisting}[language=unison]
fileRW : Request {FileRW} a ->{State FileSystemT, Error} a
fileRW result =
    match result with
        { read i -> resume } ->
            let fs = get ()
                text = fread i fs
                match text with
                    Left text -> handle resume text with fileRW
                    Right () -> 
                        handle resume "" with fileRW
        { write (i, text) -> resume } ->
            let fs = get ()
                fs' = fwrite i text fs
                put fs'
                handle resume () with fileRW
        { result } -> result
\end{lstlisting}

The handler for \texttt{FileCO} is also fairly simple. It takes a request and
matches on the operations. If the operation is \texttt{create} it returns a
fresh I-number for the new file. If the operation is \texttt{open} it returns
the I-number associated with the filename. It makes use of the underlying
\texttt{fcreate} and \texttt{fopen}.

\begin{lstlisting}[language=unison]
fileCO : Request {FileCO} a ->{FileRW, State FileSystemT, Error} a
fileCO result =
    match result with
        { create name -> resume } ->
            let fs = get ()
                (ino, fs') = fcreate name fs
                put fs'
                handle resume ino with fileCO
        { open name -> resume } ->
            let fs = get ()
                ino = fopen name fs
                put fs
                handle resume ino with fileCO
        { result } -> result
\end{lstlisting}

Finally, \texttt{FileLU} which follows the same structure as the other handlers.

\begin{lstlisting}[language=unison]
fileLU : Request {FileLU} a ->{FileRW, State FileSystemT, Error} a
fileLU result =
    match result with
        { link (src, dest) -> resume } ->
            let fs = get ()
                fs' = flink src dest fs
                put fs'
                handle resume () with fileLU
        { unlink name -> resume } ->
            let fs = get ()
                fs' = funlink name fs
                put fs'
                handle resume () with fileLU
        { result } -> result
\end{lstlisting}

\section{Pipes}

In \textsc{Unix}, a pipe is essentially syntactic sugar for connecting the input
and output of two files. Given the simple nature of the file-system described
in section \ref{sec:filesystem}, and the lack of true \texttt{stdout} and
\texttt{stdin} files, pipes are represented as effect operations that are
connected via handlers.

\texttt{Yield} and \texttt{Await} are two new effect signatures for
implementing pipes. \texttt{Yield} performs some computation and returns or
`yields' a value, \texttt{Await} takes that value as an argument and then
performs computation. Using the \texttt{yield} operation can be thought of as
writing to \texttt{stdout} and \texttt{await} is reading from \texttt{stdin}.

\begin{lstlisting}[language=unison]
unique ability Await a
    where
        await: () -> a

unique ability Yield a
    where
        yield: a -> ()
\end{lstlisting}

\subsection{Cat}
In \textsc{Unix}, \texttt{cat} prints the contents of a file to
\texttt{stdout}. In this case, pipes can be used, by yielding the file a
character at a time other utilities can simply await input.  

\begin{lstlisting}[language=unison]
cat: Text -> {FileRW, FileCO, Yield Text, e} -> ()
cat fname = 
  let ino = open fname
      iter (ch -> yield ch) (read ino)
      yield '\0'

\end{lstlisting}

\subsection{Find}

We define a new program \texttt{find} that searches for a string in a the output of a pipe. This is done by yielding the output of the pipe to the \texttt{find} function which then awaits the string to search for. If the string is found it yields true, otherwise it yields false.

\begin{lstlisting}[language=unison]
find: Text ->{Await Text} Boolean 
find target = 
  findRec target buffer n length =
    if n < length then
      findRec target (buffer ++ !await) n+1 length
    else 
      if buffer == target then
        True
      else 
        if buffer == "" then
          False
        else 
          findRec target ((drop 1 buffer) ++ !await) n length
  findRec target "" 0 (length target)

\end{lstlisting}

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 4 -- Searching in a set of files}
  
  Given a list of filenames we want to return the name of each file that
  contains a particular string. We can compose \texttt{cat} and \texttt{find}
  to achieve this.

  \begin{lstlisting}[language=unison]
  
  searchFiles: Text -> [Text] ->{FileRW, FileCO, Await Text, Yield Text, e} [Text]
  searchFiles target fnames = match fnames with 
    [] -> []
    fname +: rest -> 
      if pipe (cat fname) (find target) then
        fname ++ searchFiles target rest
      else
        searchFiles target rest

  \end{lstlisting}
\end{tcolorbox}

\subsection{Pipe and Copipe Handler}

The handlers can now be defined:

\begin{lstlisting}[language=unison]
pipe : ('{Yield b, e} a) -> ('{Await b, e} a) ->{e} a
pipe p c = handle c () with
                (cases
                    { x } -> x
                    { await () -> resume } -> copipe (resume) p)

copipe : (b -> {Await b, e} a) -> ('{Yield b, e} a) ->{e} a
copipe c p = handle p () with
                (cases
                    { x } -> x
                    { yield y -> resume } -> pipe resume '(c y) )
\end{lstlisting}

Each handler takes two arguments: a producer, \texttt{p} and a consumer,
\texttt{c}. Both arguments are suspended computations that produce a value of
type \texttt{a}. A producer may invoke \texttt{Yield} and a consumer may invoke
\texttt{Await}.

The \texttt{pipe} handler immediately handles the consumer and defines an
inline function to handle it with. If the consumer invokes an await it is
handled with the \texttt{copipe} with the producer and the resumption of the
consumer. This means that the consumer process is blocked until the producer
can produce it's value.

Similarly, the \texttt{copipe} handler runs the producer until it yields a
value, that value is then given to the suspended consumer and given back to the
pipe handler.

\section{Unix Fork}

\subsection{Process ID's}

It would be useful to be able to keep track of multiple processes.
\textsc{Unix} uses process ID's or \texttt{pid}'s for this purpose. Whenever a
program forks, fork should return a process ID of the newly created process. 
This then allows programs to `wait' for a particular process to finish.

\subsection{Effect Signature}

The updated effect signature now includes \texttt{wait} which will wait for a
process with the specified \texttt{pid}. Fork now returns the \texttt{pid} of
the newly created process. The type of interrupt remains unchanged. Fork and
interrupt are renamed to \texttt{ufork} and \texttt{uinterrupt} to avoid having
to overwrite the previous definition.

\begin{lstlisting}[language=unison]
unique ability Co 
    where 
        ufork: Nat
        wait: Nat -> ()
        uinterrupt: ()
\end{lstlisting}

\subsection{Types}

Now that the program must also handle \texttt{pid}'s there must be more state
that is capable of storing this information. \texttt{Done} and \texttt{Paused}
become \texttt{Ready} and \texttt{Blocked} as now, a process is either ready to
run, or blocked by another process. Instead of returning just a return value of
\texttt{a} it must now also return which process returned that value, hence the
\texttt{List (Nat, a)} type.

\begin{lstlisting}[language=unison]
unique type Proc a e = Proc (Sstate a e ->{e} List (Nat, a))
unique type Pstate a e = Ready (Proc a e) | Blocked Nat (Proc a e)
unique type Sstate a e = {q: List (Nat, Pstate a e), done: List (Nat, a), pid: Nat, pnext: Nat}
\end{lstlisting}

Finally, there is the \texttt{Sstate} type which has the queue of process to be
run, the list of process that are finished or done and the current and next
process ID's.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 5 -- Init process}

  When \textsc{Unix} is initialised it forks to create a new process to run all
  programs on. The original process is then the parent process of every process
  created by the operating system.

  \begin{lstlisting}[language=unison]
init: '{e} a ->{e, Co} ()
init main = let pid = ufork
                if pid == 0 then
                    let a = main ()
                        ()
                else
                    wait pid
  \end{lstlisting}

  We accept one argument \texttt{main} which is the function to be ran as the
  first program. If we are on the ancestor process ($pid = 0$) then we capture
  the return value of main while running it and return the unit type. If we are
  on any other process we wait for the main process.
\end{tcolorbox}

\subsection{Running a process}

The \texttt{runNext} function takes an argument of type \texttt{Sstate} and
runs it to produce the list of pid's and return values.

\begin{lstlisting}[language=unison]
runNext: Sstate a e ->{e} List (Nat, a)
runNext st =
    let (Sstate q done pid pnext) = st
        match q with
            [] -> done
            (pid', Blocked pid'' resume) +: q' -> 
                runNext (Sstate (q' lib.base.data.List.++ [(pid', Blocked pid'' resume)]) done pid pnext)
            (pid', Ready resume) +: q' -> 
                let st' = (Sstate q' done pid' pnext)
                    Proc (resume') = resume
                    resume' st'
\end{lstlisting}

It unpacks the \texttt{Sstate} and matches on the queue. When it encounters a
blocked process, it sends it to the back of the queue and recursively calls the
function on the new queue. When it encounters a process that is ready to be run
it unpacks the \texttt{Proc} type and gives the \texttt{Sstate} as an argument
to the resumption, thus creating the list.

\subsection{The handler}

\begin{lstlisting}[language=unison]
scheduler: Sstate a e -> Request {Co, e} a ->{e} List (Nat, a)
scheduler st request = match request with 
    { result } -> 
        let (Sstate q done pid pnext) = st 
            done' = done lib.base.data.List.++ [(pid, result)]
            runNext (Sstate q done' pid pnext)
    { ufork -> resume } -> 
        let resume' = (Proc (st -> handle resume 0 with scheduler st))
            (Sstate q done pid pnext) = st
            pid' = pnext
            pnext' = pnext + 1
            q' = q lib.base.data.List.++ [(pid', Ready resume')]
            handle resume pid' with scheduler (Sstate q' done pid pnext')
    { wait pid -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = if processExists pid q then
                     q lib.base.data.List.++ [(pid, Blocked pid resume')]
                 else q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)
    { uinterrupt -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)
\end{lstlisting}

The handler takes a \texttt{Sstate} and a request. If the request is a return
value it appends the result to the list of done processes and runs the next
process. If the request is a fork it creates a new process with the next pid
and handles it's resumption. The parent process is put back into a
\texttt{Proc} type and added to the back of the queue with a process ID of
zero. Interrupting simply causes the process to be put back into the queue as
ready to run while running the next operation. Waiting for a process is more
complex. If the process exists in the queue it is blocked and the resumption is
handled with the new state. If the process does not exist in the queue it is
added to the back of the queue as ready to run. Therefore, if the process ID it
has been asked to wait on does not exist it behaves the same as interrupt.

\chapter{Extensions}
\label{extensions}

\section{Error Handling}

Currently, whenever this implementation encounters an error or problem it will
silently fail. To address this we will introduce different types of error
through the \texttt{EType} type.

\begin{lstlisting}[language=unison]
unique type EType = PermissionDenied | FileNotFound | FileExists | UserExists | UnknownError
\end{lstlisting}

We provide common errors that might occur in \textsc{Unix} as well as a
catch-all unknown error. Now is also a good time to provide a \texttt{toText}
implementation for \texttt{EType} such that we can print them later. This is 
simply pattern matching on each possible value of \texttt{EType} and returning a sensible string for the error message:

\begin{lstlisting}[language=unison]
toText: EType -> Text
toText = cases  
    PermissionDenied -> "Permission denied"
    FileNotFound -> "File not found"
    FileExists -> "File exists"
    UserExists -> "User exists"
    UnknownError -> "Unknown error"
\end{lstlisting}

Now we can introduce the \texttt{Error} signature which provides only one
operation \texttt{throw}. Throw takes an argument of type \texttt{EType} and
returns the unit.

\begin{lstlisting}[language=unison]
unique ability Error
    where
        throw: EType -> ()

fail : Request {e, Error} a ->{e, IO, Exception, Status} Empty
fail request =
    match request with
        { throw err -> resume } -> 
            printLine (toText err)
            exit 1
        { result } -> exit 0

warn : Request {e, Error} a ->{e, IO, Exception} a
warn request =
    match request with
        { throw err -> resume } -> 
            printLine (toText err)
            handle resume () with warn
        { result } -> result
\end{lstlisting}

We provide two handlers, \texttt{fail} and \texttt{warn}. \texttt{fail} will
print the error message and exit the program with a return code of 1 thus
halting execution. \texttt{warn} will print the error message and continue
execution by handling the resumption.

\section{Environment Variables}

In the implementation outlined in Chapter \ref{baseimplementation}, the
environment is solely the user that is currently logged in. No other
information is stored or can be stored. In \textsc{Unix}, \emph{environment
variables} are used to store and get information about the current environment
from within and outside applications. In the \textsc{Unix} shell, a user can
`ask' for the value of a shell with the \texttt{\$} prefix. For example,
\texttt{echo \$USER} will print the username of the currently logged in user.
It's not just the shell -- scripts and programs can also access this
information and use it in control flow.

\subsection{Getting and Setting Environment Variables}

In the implementation detailed in section \ref{userspace} the operation
\texttt{ask} may only ever return the name of the current user. Instead of
\texttt{ask} having the type \texttt{() -> Text} it now takes an argument of
type \texttt{Text} which represents the name of the environment variable it
should lookup and return. In this way it now acts as a get operation for
environment variables. 

Now that there is a way to `get' environment variables
it makes sense to introduce a `set' operation. \texttt{setvar} takes the name
of an environment variable and another argument of type \texttt{Text}
representing it's new value and updates it in the store.

\begin{lstlisting}[language=unison]
unique ability Session
    where
        su: User -> ()
        ask: Text -> Text
        setvar: Text -> Text -> ()
\end{lstlisting}

It is now possible to update \texttt{whoami} to use this new syntax.

\begin{lstlisting}[language=unison]
whoami: '{Session} Text
whoami _ = ask "USER"
\end{lstlisting}

\subsection{Remark on Storing Environment Variables}

If this program was written in a more conventional style the arguments to
\texttt{env} (the handler for \texttt{Session}) would have to be modified to
accommodate a new argument that is the state for environment variables or a
global data structure would have to be introduced. Since this implementation
uses effect handlers the \texttt{State} handler used in the filesystem can be
added to the type signature of \texttt{env} as an effect variable meaning the
arguments to \texttt{env} do not change and no additional data structures need
be implemented. This is discussed more in section \ref{effop}.

\subsection{Updated Environment Handler}

The handler can now be updated and extended to handle the new and updated operations.

\begin{lstlisting}[language=unison]
env: User -> Request {Session} a ->{State [(User, [(Text, Text)])]} a
env user request = 
    match request with
        {result} -> result

        { ask var -> resume } -> 
            match var with 
                "USER" ->
                    match user with 
                        Alice -> handle resume "alice" with env user
                        Bob -> handle resume "bob" with env user
                        Root -> handle resume "root" with env user
                var -> 
                    let st = get ()
                        envs = lookupEnvs user st
                        val = lookupEnvVar var envs
                        handle resume val with env user

        {su user' -> resume} -> 
            handle resume () with env user'

        {setvar var val -> resume} -> 
            let st = get ()
                envs = lookupEnvs user st
                envs' = modifyEnvVar var val envs
                put (modifyEnvs user envs' st) 
                handle resume () with env user
\end{lstlisting}

The main difference aside from the new operations, is the type signature which now includes \texttt{{State [(User, [(Text, Text)])]}}

The \texttt{su} operation did not require any modification. \texttt{ask} now
uses it's first argument to check if the environment variable being requested
is \texttt{``USER''} or another variable. If it is user it calls resume with
the hard-coded \texttt{Text} version of the user.  In the general case it uses
lookup functions that navigate the environment variables data structure and
return the correct value for the correct user. This mix of hard coded and user
defined environment variables is caused by the hard coded users, and is fixed
in the next section, section \ref{genericusers}.

Another interesting feature is the case where a program requests the value of
an environment variable that is not set. \textsc{Unix} will return an empty
string in this case so \texttt{lookupEnvVar} will return an empty string if it
does not exist.

\subsection{Unlisted Functions}

The above handler makes use of the functions \texttt{lookupEnvVar,
modifyEnvVar, lookupEnvs, modifyEnvs} and \texttt{userEquals}. The lookup and
modify functions traverse and update the \texttt{[(User, [(Text, Text)])]} data
structure that environment variables are stored in and \texttt{userEquals}
returns true if the two given users are the same. These functions are listed in
the appendix.

\section{Generic Users}
\label{genericusers}

Now that there are user-defined environment variables it makes sense to add
user-defined users as well. The \texttt{User} type is modified to have a
\texttt{Username} constructor which allows a user to be constructed with an
argument of type \texttt{Text}.

\begin{lstlisting}[language=unison]
unique type User = Username Text
\end{lstlisting}

\subsection{Effect Operation}

The \texttt{Session} operation can now be extended to allow privileged users to
create new users. \texttt{adduser} takes one argument of type \texttt{Text}
which is the username of the new user.

\begin{lstlisting}[language=unison]
unique ability Session
    where
        su: Text -> ()
        ask: Text -> Text
        export: Text -> Text -> ()
        adduser: Text -> ()
\end{lstlisting}

\subsection{Changes to the Handler}

The only operations that need to be modified is \texttt{su} and \texttt{ask}.
\emph{Substitute user} now checks if the user exists through the
\texttt{userExists} function. There is no need to introduce additional state to
create new users, the handler simply uses the \texttt{[(User, [(Text, Text)])]}
data structure to keep track of both the users and their environment variables.

\begin{lstlisting}[language=unison]
{su user' -> resume} -> 
    if userExists (Username user') (get ()) then
        handle resume () with env (Username user')
    else 
        throw UserDoesntExist
        handle resume () with env user   -- fail
\end{lstlisting}

To add a new user the handler checks if there is already an instance of that
user in the state. If there is it just handles the resumption without modifying
the state. If the user does not exist then it adds the user to the state along
with an entry in the new users environment variables called \texttt{USER} which
can be accessed by \texttt{ask}.

\begin{lstlisting}[language=unison]
{adduser user' -> resume} ->
            let st = get ()
                    newuser = (Username user')
                    if not (userExists newuser st) then
                        newvars = [("USER", user')]
                        newenv = modifyEnvs newuser newvars st
                        put newenv
                        handle resume () with env newuser
                    else 
                        handle resume () with env user

\end{lstlisting}

Finally, the match statement can be removed from \texttt{ask} as now when a user is created they are created with the \texttt{"USER"} environment variable set. The last step is to add an initial userspace which just contains the root user and their environment variable.

\begin{lstlisting}[language=unison]
initialUserspace : [(User, [(Text, Text)])]
initialUserspace = [(Username "root", [("USER", "root")] )]
\end{lstlisting}

Userspace code can now be run with \texttt{handle (handle ... with env (Username "root")) with initialUserspace}.


\section{Permissions}
\label{permissions}

In Unix file permissions are stored in the I-node of a file.
In this implementation, we demonstrate how an effect handler can be used to manage permissions.
First, we introduce a new type \texttt{Permission} which represents the different types of permissions that can be granted to a user. We also introduce \texttt{all} which is a list containing every permission.

\begin{lstlisting}[language=unison]
unique type Permission = Read | Write | AddUser | Grant | Revoke | Execute

all : [Permission]
all = [Read, Write, AddUser, Grant, Revoke, Execute]
\end{lstlisting}

Now we need a way to modify a user's permissions. \texttt{grant} and \texttt{revoke} are two new operations that take a username and a permission and either add or remove that permission from the user's list of permissions.

\begin{lstlisting}[language=unison]
unique ability Permit 
    where 
        grant: Text -> Permission -> ()
        revoke: Text -> Permission -> ()
\end{lstlisting}

Finally we introduce the monolithic handler that we use to implement permissions. Notice the handler handles every effect we have defined thus far although notice from the right hand side of the type signature, that it only handles the \texttt{Permit} abilities.

\begin{lstlisting}[language=unison]
permissions: User -> Request {e, Permit, Session, FileRW, FileLU, FileCO, Co} a ->{e, Session, FileRW, FileLU, FileCO, Co, Error, State [(Text, [Permission])], IO, Exception} a
permissions user request = 
    match request with
        -- Permissions 
        {grant user' perm -> resume} -> 
            checkPermission user Grant !get
            existingPerms = lookupPermission user' !get 
            newPerms = perm +: existingPerms
            put (modifyPermission user' newPerms !get)
            handle resume () with permissions user
        
        {revoke user' perm -> resume} ->
            checkPermission user Revoke !get
            newPerms = removePermission perm (lookupPermission user' !get)
            put (modifyPermission user' newPerms !get)
            handle resume () with permissions user

        -- Users
        {ask var -> resume} -> 
            checkPermission user Read !get
            answer = ask var
            handle resume answer with permissions user 
        {su user' -> resume} -> 
            su user'
            handle resume () with permissions (Username user')
        {adduser user' -> resume} -> 
            checkPermission user AddUser !get
            adduser user'
            handle resume () with permissions user
        {export var val -> resume} -> 
            checkPermission user Write !get
            export var val
            handle resume () with permissions user

        -- Files
        {read i -> resume} -> 
            checkPermission user Read !get
            text = read i
            handle resume text with permissions user

        {write (i, text) -> resume} -> 
            checkPermission user Write !get
            write (i, text)
            handle resume () with permissions user
        
        {link (src, dest) -> resume} -> 
            checkPermission user Write !get
            link (src, dest)
            handle resume () with permissions user
        
        {unlink name -> resume} ->
            checkPermission user Write !get
            unlink name
            handle resume () with permissions user

        {create name -> resume} -> 
            checkPermission user Write !get
            ino = create name
            handle resume ino with permissions user

        {open name -> resume} ->
            checkPermission user Read !get
            ino = open name
            handle resume ino with permissions user

        {ufork -> resume} ->
            checkPermission user Execute !get
            let pid = ufork
                handle resume pid with permissions user

        {wait pid -> resume} ->
            checkPermission user Execute !get
            wait pid
            handle resume () with permissions user

        {uinterrupt -> resume} ->
            checkPermission user Execute !get
            uinterrupt
            handle resume () with permissions user

        {result} -> result
\end{lstlisting}

The handler works by once again using the \texttt{State} effect to store a list
of users and their permissions. Whenever the handler encounters an effect it
will check the currently logged in users permissions, and if the user has the
corerct permissions, it will run the original effect with it's original
arguments. The handler keeps track of which user is logged in through the user
argument to itself. If it encounters a \texttt{su} operation it will update
this value.

The \texttt{grant} and \texttt{revoke} operations are implemented by simply 
traversing and modifying the data structure stored by the \texttt{State} effect.

The final step is to add an initial permissions list which contains the root
user and all permissions.

\begin{lstlisting}[language=unison]
initialPermissions : [(Text, [Permission])]
initialPermissions = [("root", all)]
\end{lstlisting}

\subsection{Remark on Multihandlers Handlers in Unison}

In the implementation of the permissions handler, there is a lot of repeated
code this is because we are forced to explicitly handle every effect. There is
no way to condense the repeat definitions into a pattern match or similar
within the match statement. This is discussed further in section
\ref{multihandler}. 

\section{An Alternate Scheduler}

The scheduler in section \ref{extensions} is a simple round-robin scheduler
while not dissimilar to \textsc{Unix}'s multilevel feedback queue round robin
scheduler it is much more simplistic. Even in widely used systems like Linux
which switches between multiple algorithms, scheduling remains very much
unsolved \cite{Lozi2016}.

To improve the scheduler we introduce the concept of priority levels through a
nice value. In Linux, nice values range from -20 to 19 with -20 being the
highest priority. Each process has a nice value associated with it that the
user can manually change to increase or decrease the priority of a process. 

\subsection{Effect Signature}

The \texttt{Co} effect signature is updated to include \texttt{nice} and
\texttt{renice} operations for getting and setting nice values respectively.

\begin{lstlisting}[language=unison]
unique ability Co 
    where 
        ufork: Nat
        wait: Nat -> ()
        uinterrupt: ()
        nice: Nat -> Int
        renice: Nat -> Int -> ()
\end{lstlisting}

To avoid breaking the original \texttt{scheduler} these effects are handled but
simply handle the resumption and perform no computation.

\subsection{Priority Queue}

The next step is to create a new \texttt{runNext} function that takes into
account the nice value of each process.

\begin{lstlisting}[language=unison]
runNextNice: Sstate a e -> [(Nat, Int)] ->{e} List (Nat, a)
runNextNice st niceValues = 
    let (Sstate q done pid pnext) = st
        match q with
            [] -> done
            (pid', Blocked pid'' resume) +: q' -> 
                runNextNice (Sstate (q' lib.base.data.List.++ [(pid', Blocked pid'' resume)]) done pid pnext) niceValues
            (pid', Ready resume) +: q' ->
                match lowestNiceInQueue niceValues q with
                    Left (pid', Ready resume) -> 
                        let st' = (Sstate q' done pid' pnext)
                            Proc (resume') = resume
                            resume' st'
                    Left (pid', Blocked pid'' resume) ->             -- unreachable
                        let st' = (Sstate q' done pid' pnext)
                            Proc (resume') = resume
                            resume' st'
                    Right () -> 
                        let st' = (Sstate q' done pid' pnext)
                            Proc (resume') = resume
                            resume' st'
\end{lstlisting}

The function \texttt{lowestNiceInQueue} takes a list of pairs of procces ID's
and nice values and the \texttt{Sstate} it is the same as \texttt{runNext}
apart from the ready branch. Instead it checks if the is a process that is
ready to be run with a lower nice value than the one at the front of the list.
If there is it runs that instead. The Blocked branch is unreachable as
\texttt{lowestNiceInQueue} will always return a ready process but it must be
put there to satisfy the typechecker.

\subsection{An Aging Scheduler}

An aging scheduler is a type of scheduler that increases the priority of a
process the longer it has been waiting. This is done to prevent starvation of
low priority processes that otherwise would not be run. This is achieved by
increasing the priority of a process every time it forks and setting it's child
to have it's old nice value.

The scheduler is implemented through a modified version of the
\texttt{scheduler} handler. As such only the operations that have changed or
been added are listed, the others just have \texttt{runNext} swapped for
\texttt{runNextNice}.

\begin{lstlisting}[language=unison]
schedAging: Sstate a e -> Request {Co, e} a ->{e, State [(Nat, Int)]} List (Nat, a)
schedAging st request = match request with
    ....
    { ufork -> resume } ->
        let resume' = (Proc (st -> handle resume 0 with scheduler st))
            (Sstate q done pid pnext) = st
            nicevalue = lookupNice pid !get

            if nicevalue - +1 <= minNice then
                let q' = q lib.base.data.List.++ [(pid, Ready resume')]
                    pid' = pnext
                    pnext' = pnext + 1
                    handle resume pid' with scheduler (Sstate q' done pid pnext')
            else
                put (modifyNice pnext nicevalue !get)
                put (modifyNice pnext (nicevalue - +1) !get)

                pid' = pnext
                pnext' = pnext + 1

                q' = q lib.base.data.List.++ [(pid', Ready resume')]
                handle resume pid' with schedAging (Sstate q' done pid pnext)

    { nice pid -> resume } ->
        let (Sstate q done pid pnext) = st
            nicevalue = lookupNice pid !get
            handle resume nicevalue with schedAging st

    { renice pid newNice -> resume} -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            put (modifyNice pid newNice !get)
            runNextNice (Sstate q done pid pnext) !get
    ...
\end{lstlisting}

The interesting case here is fork where the nice value of the parent is
decreased by one and the child is set to the old nice value of the parent. This
will cause process that have been waiting for a long time to have a higher and
hopefully be run sooner.

\subsection{Simple Starvation Heuristic}

Yet another improvement to the scheduler is to introduce a simple heuristic to
prevent starvation. The heuristic is that if a process reached minimum nice
through a fork then it has probable been interrupt a lot and as such is
unlikely to run even if we adjust the nice. To save on the extra computation of
handling nice values we can switch back to the round robin scheduler just by
handling the same state with the old handler.

\chapter{Evaluation and Discussion}

\section{Unison}

The following section details some of the quirks and missing features of the Unison
effect systsem that were encountered during the implementation of \textsc{Unix}.

\subsection{Multihandler Pattern Matching}
\label{multihandler}

If we consider a handler, like the one in section \ref{permissions} for
permissions, that handles multiple effects, it would be useful to be able to
pattern match on the effect signature or across multiple operations and invoke
them once.

For example, in the permissions handler there is lots of repeated code of the general form:

\begin{lstlisting}
  { [effect] [args] -> resume } -> 
    checkPermission user perm !get
    [effect] [args]
    handle resume () with permissions user
\end{lstlisting}

If we were allows to have a syntax like \texttt{\{effect1 | effect2 | effect3\}
[args] -> resume} then we could condense the repeated code into a single branch
of the match statement. Even if we could only perform this match for operations
of the same effect signature it would still massively reduce code reuse.

\begin{lstlisting}[language=unison]
permissions: User -> Request {e, Permit, Session, FileRW, FileLU, FileCO, Co} a ->{e, Session, FileRW, FileLU, FileCO, Co, Error, State [(Text, [Permission])], IO, Exception} a
  {grant user' perm -> resume} -> ...

  {revoke user' perm -> resume} -> ...

  { read i -> resume } | { write (i, text) -> resume } | { link (src, dest) -> resume } | { unlink name -> resume } | { create name -> resume } | { open name -> resume } | ... -> 
    checkPermission user Read !get
    {ability args}
    handle resume () with permissions user
\end{lstlisting}

You could even borrow the \texttt{!} syntax and have \texttt{!ability} to represent running an ability with its given arguments.
With this theoretical syntax the size and complexity of the handler is massively reduced.

\subsection{Effect Variables in Definitions}

In the Unison documentation \cite{unison-abilities} they suggest defining
abilities with the effct signature as part of the type signature of the effect
to represent needing access to the ability to be run. For example

\begin{lstlisting}[language=unison]
unique ability Await a
  where
    await : () ->{Await a} a
    yield : a ->{Await a} ()
\end{lstlisting}

However, the effect signature \texttt{\{Await a\}} is inferred by the fact
\texttt{await} and \texttt{yield} are operations of the \texttt{Await} ability.
You might think it is useful to be able to include other effects but if we were
to do \texttt{await : () ->\{Await a, Yield a\} a} then the type checker stops
us with the error \texttt{  EffectConstructorHadMultipleEffects: {Await a3420,
Yield a3420} a3420}. Furthermore, if you mistakenly put the signature
\texttt{await () ->\{Await\} a} i.e. you missed the type of a from the
\texttt{Await} effect variable, then it will attempt to infer the type of
\texttt{Await} and will no longer throw an error. This is fine until you try to use the effect in a function when you are met with abstract errors like: 

\begin{lstlisting}[style=terminal]
  The expression in red
  
                needs the abilities: {Yield b3407}
    but was assumed to only require: {Yield a3434, e3439}

      This is likely a result of using an un-annotated function as an argument with concrete abilities. Try adding an annotation to the function definition whose body is red.
  
    511 |                     { await () -> resume } -> copipe (resume) p)
\end{lstlisting}

This error points towards the \texttt{copipe} function as the source of the
error which in this case is completely fine.

I suggest to anyone using Unison to avoid including effect variables in the
definition of an ability as it can lead to confusing and abstract errors.
Furthermore, I would encourage the Unison team to consider removing this
feature as it seems to cause more problems than it solves. If it is always
inferred to be the correct type then there is no need to allow a user to set it
to an incorrect type.


\section{Effect Oriented vs Conventional Programming}
\label{effop}

Consider the following hypothetical implementation of the environment operations from Section \ref{userspace}, which has been implemented in a more conventional style.
.

\begin{lstlisting}[language=unison]
adduser': [User] -> Text -> [User]
adduser' store user =
    store :+ (Username user)

su' : [User] -> User -> [User]
su' store user =
    match store with
        [] -> store
        (u +: rest) ->
            let uname = userToText u
                username = userToText user
                if uname == username then
                    u +: rest
                else
                    store

ask': [User] -> Text
ask' store =
    match store with
        [] -> ""
        (u +: rest) ->
            let uname = userToText u
                uname
\end{lstlisting}

In this version, all the state for the users is stored in a list of users where
the first one in the list is the currently logged in user. This is already more
irksome than the handler implementation as the user of the functions has to keep
track of the state themselves through the return values of \texttt{su'} and
\texttt{adduser'}.

If we compare this to the handler version the state is set once at the beginning
by setting which user is logged in initially and then once a block of code is
being handled the user can ignore the state as it is hidden from them.


\begin{figure}[h]
  \label{fig:seqvshandler}
\begin{minipage}{0.5\textwidth}

\begin{lstlisting}[style=terminal]
createAndSwitch: Text -> ()
createAndSwitch user =
  adduser user
  su user


> handle createAndSwitch ``alice'' with (Username ''root'')

\end{lstlisting}

\end{minipage}%
\begin{minipage}{0.5\textwidth}


\begin{lstlisting}[style=terminal]
  createAndSwitch': Text -> [User] -> [User]
  createAndSwitch' user state =
    let newState = adduser' state user
      su' newState user

> createAndSwitch' ``alice'' [(Username ``root'')]

\end{lstlisting}
\end{minipage}
\caption{Effect oriented version (\emph{left}) and the standard version (\emph{right})}
\end{figure}

\subsection{Modularity}

The comparison in Listing \ref{fig:seqvshandler} shows that although both versions require initial state,
the power of effect handlers allow us to keep the implementation separate from
the use and as such there is no requirement for the function to manage the state of
users. As long as the program is run within scope of the handler all operations
will have access to this state. The result of this is that the effect operations
behave much more like \textsc{Unix} commands as they can be called without
having to pass around variables.

Additionally, if we wanted to provide an alternate implementation of
\texttt{adduser} that logs in the newly created user we could easily accomplish
this by writing an alternate handler for \texttt{adduser}. The conventional
version would require a whole new function to be written just to change the line
\texttt{store :+ (Username user)} to \texttt{(Username user) +: store}. Then
once that new function was written, we would have to manually change every
occurence of \texttt{adduser'} where we want to use the new semantics. The
effect oriented version keeps the same operation and we simply handle any
functions where we need the new version with the new handler. A much more
seamless style of coding.

\subsection{Composition}

When we added environment variables to the userspace it was as simple as adding
the \texttt{State} effect signature with the type being the data structure we
need. This means in the scope of the \texttt{env} function where this was added
we could immediately start using \texttt{put} and \texttt{get} to manage the
state of users and environment variables. We didn't even need to define a new
handler the \texttt{State} handler can accept any algebraic data type as the
type to put and get meaning it was as simple as adding another \texttt{handle}
statement and then modifying the operations.

In contrast, to add environment variables to the conventional code we must
modify the data type used to store users to be something like \texttt{unique
type Environment = \{usr: User, envs: [(Text, Text)]\}}. Then all occurrences of
the operations must be modified to give them values of the new type. The effect
oriented one simply adds a handle statement and once again leaves the type
signatures of the operations unchanged.

\subsection{Performance}

Unfortunately, in Unison there is an enormous performace impact caused by using
abilities. Using the timers micro-benchmarking library \cite{timers}, I ran code
that created a user with a random name, and switched to that user. It then
repeated this action 1000 times and recorded the results.

\begin{table}[htbp]
    \centering
    \begin{tabular}{lcc}
        \toprule
        \textbf{Metric} & \textbf{Effectful} & \textbf{Conventional} \\
        \midrule
        Samples           & 1                  & 1 \\
        \midrule
        Total (realtime)  & 2.021658s          & 15s \\
        Mean (realtime)   & 2.021658s          & 15s \\
        Median (realtime) & 2.021658s          & 15s \\
        Min (realtime)    & 2.021658s          & 15s \\
        Max (realtime)    & 2.021658s          & 15s \\
        \midrule
        Total (cpu)       & 2.152157s          & 26s \\
        Mean (cpu)        & 2.152157s          & 26s \\
        Median (cpu)      & 2.152157s          & 26s \\
        Min (cpu)         & 2.152157s          & 26s \\
        Max (cpu)         & 2.152157s          & 26s \\
        \bottomrule
    \end{tabular}
    \caption{Benchark results for creating and switching to 1000 randomly generated users}
    \label{tab:label_comparison}
  \end{table}

  The results are clear -- the effect oriented version is orders of magnitude
slower. Even accounting for the fact it has extra overhead for error handling
and environment variables it is still far slower. This may be due to the
compiler being better optimised for purely functional applications and it would
be interesting to see how the effects are implemented in Unison for this reason.


\chapter{Conclusion and Future Work}

\section{Base Implementation}

\subsection{Summary}

The basic implementation of Unix was a success as every feature outlined by 
Hillerstr\"{o}m was implemented in Unison. 

\subsection{Future Work}

\emph{\textbf{Shell}} A logical extension to this project would be creating a shell like \texttt{bash}
or similar to allow users to run the commands in a more real-time way. Writing a
shell would be mostly implementing the parser which is usually unrelated to
effect oreinted programming which is why it was omitted from this project.  It
may also be interesting to see if parsers can be written in an effect oriented
style and if there is any benefit to this approach.

\emph{\textbf{Implementation in other languages}} Another interesting project
would be to implement the same Unix in another language that has effect handlers like
Frank or Koka and compare the two implementations. This would allow for a more
direct comparison of the two languages and their effect systems.

\section{Extended Implementation}

\subsection{Summary}

While the extension was successful in that new features were added, not all of them 
were as polished as the base implementation. The permissions system was a success
and a good example of using a multihandler as state. The scheduler was less successful
as it was unlikely to actually improve the performance of the system and was more
of a demonstration of how effect handlers can be used to implement complex systems.

\subsection{Future Work}

\emph{\textbf{Grep}} Implementing a version of grep would be a good way to
provide some more advanced examples of effect handlers. This would involve
parsing regular expressions from the pipe command and then matching based on 
the regular expression.

\emph{\textbf{Linux}} Another interesting project would be attaching effect handlers to Linux. This could be done through a kernel module and then used for other applications like writing another scheduling algorithm or making the filesystem closer to the one outlined in \cite{DBLP:conf/context/KiselyovS07}. The scope of the project would have to be reduced to the complexity and size of linux. It would also be a good opportunity to explore performant effects.

\section{Evaluation}

\subsection{Summary}

It is hard to say if effect oriented programming is better or worse than
conventional programming. The performance impact of using effects can be
considerable but the syntax can be much more concise and modular. For this
reason we are more outlining differences and areas were the effect handlers are
probably better (i.e. their modularity and composing them) and some pain points
like performance that exist in the Unison implementation. We also suggest some
potential improvements to the Unison effect system that would make it better
equipped for multihandlers.

\subsection{Future Work}

\emph{\textbf{Performance}} The performance of any technology is a major
consideration in it's adoption by industry. It would be useful to do more
thorough profiling of the Unison compiler to see where the performance
bottlenecks are and if they can be improved.

\emph{\textbf{Comparison with a more traditional implementation}} Although this 
was partly covered in the evaluation section it would be interesting to see how
the effect oriented version of Unix compares to a more traditional version in
a more complete and thorough way. This would involve implementing the same
features without the use of effect handlers and comparing them.

\section{Final Thoughts}

The Unison effect system is as powerful and expressive as any other effect
system. It is capable of writing complex effect oriented programs like Unix and 
despite some performance issues it is a very promising language. Overall, this project 
has achieved it's goals and has provided a demonstration of the power of effect
oriented programming. While it is not perfect it is a good starting point for future
work in this area.
The Unix implementation created could serve as good platform for further
development and exploration of effect oriented programming. More features 
can always be added and the system can be made more robust and efficient.

To conclude, the effect oriented programming is here to stay and it is likely
that it will become more popular as more languages like Unison adopt it. 

\part{Appendices}

\chapter{Final State of the Code}

\section{Base Implementation}

\begin{lstlisting}[language=unison]
\end{lstlisting}

\section{Extended Implementation}

The final version of the code after all the extensions outlined in chapter \ref{extensions} were implemented.

\begin{lstlisting}[language=unison]
{-
    BasicIO
    =========
-}

unique ability BasicIO
    where
        echo: Text -> ()

basicIO : Request {BasicIO} a ->{IO, Exception} a
basicIO result =
    match result with
        { echo text -> resume } -> putText stdOut text; handle resume () with basicIO
        { result } -> result


{-
    Status
    =========
-}

unique type Empty = 

-- The unix exit command that allows you to exit with error code
unique ability Status
       where
            exit: Nat -> Empty

-- handles the exit command which just returns an integer
exitHandler : Request {g, Status} a -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> v

{-
Userspace
==========

This handles the hard coded users and their environments.
It allows for whoami and su commands to be run.

-}

-- The users (hard coded)
unique type User = Username Text

unique ability Session
    where
        su: Text -> ()
        ask: Text -> Text
        setvar: Text -> Text -> ()
        adduser: Text -> ()

whoami: '{Session} Text
whoami _ = ask "USER"

env: User -> Request {Session} a ->{Error, State [(User, [(Text, Text)])]} a
env user request = 
    match request with
        {result} -> result

        { ask var -> resume } -> 
           let st = get ()
               envs = lookupEnvs user st
               val = lookupEnvVar var envs
               handle resume val with env user

        {su user' -> resume} -> 
            if userExists (Username user') (get ()) then
                handle resume () with env (Username user')
            else
                throw NoSuchUser
                handle resume () with env user   -- fail

        {setvar var val -> resume} -> 
            let st = get ()
                envs = lookupEnvs user st
                envs' = modifyEnvVar var val envs
                put (modifyEnvs user envs' st) 
                handle resume () with env user

        {adduser user' -> resume} ->
            let st = get ()
                newuser = (Username user')
                newvars = [("USER", user')]
                newenv = modifyEnvs newuser newvars st
                if not (userExists newuser st) then
                    put newenv
                    handle resume () with env newuser
                else 
                    throw UserExists
                    handle resume () with env user

lookupEnvVar: Text -> [(Text, Text)] -> Text
lookupEnvVar var env =
    match env with
        [] -> ""
        (var', val) +: rest ->
            if var == var' then val
            else lookupEnvVar var rest

modifyEnvVar: Text -> Text -> [(Text, Text)] -> [(Text, Text)]
modifyEnvVar var val env =
    match env with
        [] -> [(var, val)]
        (var', val') +: rest ->
            if var == var' then (var, val) +: rest
            else (var', val') +: modifyEnvVar var val rest

lookupEnvs: User -> [(User, [(Text, Text)])] -> [(Text, Text)]
lookupEnvs user envs =
    match envs with
        [] -> []
        (user', env) +: rest ->
            if userToText user == userToText user' then env
            else lookupEnvs user rest

modifyEnvs: User -> [(Text, Text)] -> [(User, [(Text, Text)])] -> [(User, [(Text, Text)])]
modifyEnvs user env envs =
    match envs with
        [] -> [(user, env)]
        (user', env') +: rest ->
            if userToText user == userToText user' then (user, env) +: rest
            else (user', env') +: modifyEnvs user env rest

userExists: User -> [(User, [(Text, Text)])] -> Boolean
userExists user envs =
    match envs with
        [] -> false
        (user', env) +: rest ->
            if userToText user == userToText user' then true
            else userExists user rest

userToText: User -> Text
userToText user = 
    let (Username username) = user
        username

initialUserspace : [(User, [(Text, Text)])]
initialUserspace = [(Username "root", [("USER", "root")] )]

{-
      Time Sharing
   ==================
-}

unique ability Interrupt
    where
        interrupt: {Interrupt } ()


unique type PState a e = Done a | Paused ('{e} PState a e)

interruptWrite : Request {e, BasicIO} x ->{e, Co, BasicIO} ()
interruptWrite result =
    match result with
        { echo text -> resume } -> 
            uinterrupt
            echo text 
            handle resume () with interruptWrite
        { result } -> ()

reifyProcess : Request {Interrupt, e} a -> PState a e
reifyProcess request =
    match request with
        { interrupt -> resume } -> Paused (_ -> handle !resume with reifyProcess )
        { result } -> Done result

unique ability TimeSharing
    where
        fork: {TimeSharing } Boolean

-- handler for time sharing ability
nondet : Request {TimeSharing} a -> [a]
nondet request =
    match request with
        { fork -> resume } -> (handle resume true with nondet) lib.base.data.List.++ (handle resume false with nondet)
        { result } -> [result]

sched : [PState a {e, TimeSharing}] -> [a] ->{e} [a]
sched ps done = 
    match ps with
        [] -> done
        (Done res) +: ps' -> sched ps' (res lib.base.data.List.+: done)
        (Paused m) +: ps' -> sched (ps' lib.base.data.List.++ (handle !m with nondet)) done

timeshare : '{g, Interrupt, TimeSharing} o ->{g} [o]
timeshare m = sched [Paused (_ -> handle !m with reifyProcess)] []

{-
  Serial File System
  ==================
-}

unique ability State a
       where
            put: a -> ()
            get: () -> a

runState : a -> Request {State a} b -> b
runState v request =
    match request with
        { put v' -> resume } -> handle resume () with runState v'
        { get () -> resume } -> handle resume v with runState v
        { result } -> result

unique type DirectoryT = Directory (Text, Nat)
unique type DataRegionT = DataRegion (Nat, Text)
unique type INodeT = INode Nat Nat
unique type IListT = IList (Nat, INodeT)
unique type FileSystemT = FileSystem (List DirectoryT) (List IListT) (List DataRegionT) Nat Nat


initialINode : INodeT
initialINode = INode 0 0

initialDirectory : DirectoryT
initialDirectory = (Directory ("stdout", 0))


initialDataRegion : DataRegionT
initialDataRegion = DataRegion (0, "")

initialIList : IListT
initialIList = IList (0, initialINode)

initialFileSystem : FileSystemT
initialFileSystem = FileSystem [initialDirectory] [initialIList] [initialDataRegion] 0 0

lookupINode : Nat -> [IListT] -> Either INodeT ()
lookupINode i ilists =
    match ilists with
        [] -> Right ()
        (IList (i', inode)) +: rest ->
            if i == i' then Left inode
            else lookupINode i rest

lookupFName : Text -> [DirectoryT] -> Either Nat ()
lookupFName name directories =
    match directories with
        [] -> Right ()
        (Directory (name', i)) +: rest ->
            if name == name' then Left i
            else lookupFName name rest

modifyINode : Nat -> INodeT -> [IListT] -> [IListT]
modifyINode i inode ilists =
    match ilists with
        [] -> []
        (IList (i', inode')) +: rest ->
            if i == i' then (IList (i, inode)) +: rest
            else (IList (i', inode')) +: modifyINode i inode rest

lookupDataRegion : Nat -> [DataRegionT] -> Either Text ()
lookupDataRegion i dataRegions =
    match dataRegions with
        [] -> Right ()
        (DataRegion (i', text)) +: rest ->
            if i == i' then Left text
            else lookupDataRegion i rest

modifyDataRegion : Nat -> Text -> [DataRegionT] -> [DataRegionT]
modifyDataRegion i text dataRegions =
    match dataRegions with
        [] -> []
        (DataRegion (i', text')) +: rest ->
            if i == i' then (DataRegion (i, (text' ++ text))) +: rest
            else (DataRegion (i', text')) +: modifyDataRegion i text rest

-- fread, implementation of system read
fread : Nat -> FileSystemT -> Either Text ()
fread i fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            match lookupDataRegion dataRegion dataRegions with
                                Left text -> Left text
                                Right () -> Right ()
                Right () -> Right ()

-- fwrite, writes to the file system at the given inode with the given text
fwrite : Nat -> Text -> FileSystemT -> FileSystemT
fwrite i text fs =
    match fs with
        FileSystem directories ilists dataRegions _ _ ->
            match lookupINode i ilists with
                Left inode ->
                    match inode with
                        INode _ dataRegion ->
                            FileSystem directories (modifyINode i (INode i dataRegion) ilists) (modifyDataRegion dataRegion text dataRegions) 0 0
                Right () -> fs

unique ability FileRW
         where
                read: Nat -> {FileRW } Text
                write: (Nat, Text) -> {FileRW } ()

fileRW : Request {FileRW} a ->{State FileSystemT, Error} a
fileRW result =
    match result with
        { read i -> resume } ->
            let fs = get ()
                text = fread i fs
                match text with
                    Left text -> handle resume text with fileRW
                    Right () -> 
                        throw FileNotFound
                        handle resume "" with fileRW
        { write (i, text) -> resume } ->
            let fs = get ()
                fs' = fwrite i text fs
                put fs'
                handle resume () with fileRW
        { result } -> result


fileEcho: Request {BasicIO} a ->{State FileSystemT} a
fileEcho m = match m with 
    { echo text -> resume } -> 
        let fs = get ()
            put (fwrite 0 text fs)
            handle resume () with fileEcho
    { result } -> result


fopen : Text -> FileSystemT ->{Error} Nat
fopen name fs = 
    match fs with
        FileSystem directories ilists dataRegions dnext inext ->
            match lookupFName name directories with
                Left i -> i
                Right () -> 
                    throw FileNotFound
                    inext

has : Text -> [DirectoryT] -> Boolean
has name directories =
    match directories with
        [] -> false
        (Directory (name', i)) +: rest ->
            if name == name' then true
            else has name rest

fcreate : Text -> FileSystemT -> (Nat, FileSystemT)
fcreate name fs = 
    match fs with 
        FileSystem directories ilists dataRegions dnext inext ->
            -- file already exists, overwrite it
            if has name directories then 
                let ino = (fopen name fs)
                    inode = lookupINode ino ilists
                    match inode with
                        Left inode -> 
                            match inode with 
                                INode ino loc ->
                                    let dreg' = modifyDataRegion loc "" dataRegions
                                        (ino , FileSystem directories ilists dreg' dnext inext)
                        Right () -> (ino, fs) -- unreacable
            else 
                let inext' = inext + 1
                    dnext' = dnext + 1
                    inode = INode inext dnext
                    ilists' = (IList (inext, inode)) +: ilists
                    directories' = (Directory (name, inext)) +: directories
                    (inext, FileSystem directories' ilists' dataRegions dnext' inext')

unique ability FileCO
    where
        create: Text -> Nat
        open: Text -> Nat

fileCO : Request {FileCO} a ->{FileRW, State FileSystemT, Error} a
fileCO result =
    match result with
        { create name -> resume } ->
            let fs = get ()
                (ino, fs') = fcreate name fs
                put fs'
                handle resume ino with fileCO
        { open name -> resume } ->
            let fs = get ()
                ino = fopen name fs
                put fs
                handle resume ino with fileCO
        { result } -> result

flink: Text -> Text -> FileSystemT ->{Error} FileSystemT
flink src dest fs =
    match fs with
        FileSystem directories ilists dataRegions dnext inext ->
            if has dest directories then
               fs -- error, file exists
            else
                let ino = lookupFName src directories
                    match ino with
                        Left ino ->
                            let directories' = (Directory (dest, ino)) +: directories
                                inode = lookupINode ino ilists
                                match inode with
                                    Left inode ->
                                        match inode with
                                            INode ino loc ->
                                                  let loc' = loc + 1
                                                      inode' = INode ino loc'
                                                      ilists' = modifyINode ino inode' ilists
                                                      FileSystem directories' ilists' dataRegions dnext inext
                                    Right () -> 
                                        throw FileExists
                                        fs -- unreachable, we know the file exists
                        Right () -> 
                            throw FileNotFound
                            fs -- no such file src

removeINode : Nat -> [IListT] -> [IListT]
removeINode i ilists =
    match ilists with
        [] -> []
        (IList (i', inode)) +: rest ->
            if i == i' then rest
            else (IList (i', inode)) +: removeINode i rest

removeDataRegion : Nat -> [DataRegionT] -> [DataRegionT]
removeDataRegion i dataRegions =
    match dataRegions with
        [] -> []
        (DataRegion (i', text)) +: rest ->
            if i == i' then rest
            else (DataRegion (i', text)) +: removeDataRegion i rest

removeDirectory : Text -> [DirectoryT] -> [DirectoryT]
removeDirectory name directories =
    match directories with
        [] -> []
        (Directory (name', i)) +: rest ->
            if name == name' then rest
            else (Directory (name', i)) +: removeDirectory name rest

funlink: Text -> FileSystemT -> FileSystemT
funlink name fs =
    match fs with
        FileSystem directories ilists dataRegions dnext inext ->
            if has name directories then
                let ino = lookupFName name directories
                    match ino with
                        Left ino ->
                             let directories' = removeDirectory name directories
                                 inode = lookupINode ino ilists
                                 match inode with
                                        Left inode ->
                                            match inode with
                                                INode ino loc ->
                                                    if loc > 1 then
                                                        let loc' = loc - 1
                                                            inode' = INode ino loc'
                                                            ilists' = modifyINode ino inode' ilists
                                                            FileSystem directories' ilists' dataRegions dnext inext
                                                    else
                                                        let ilists' = removeINode ino ilists
                                                            dataRegions' = removeDataRegion loc dataRegions
                                                            FileSystem directories' ilists' dataRegions' dnext inext
                                        Right () -> fs -- unreachable, we know the file exists
                        Right () -> fs -- no such file src
            else
                fs -- no such file


unique ability FileLU
       where
            link: (Text, Text) -> {FileLU } ()
            unlink: Text -> {FileLU } ()

fileLU : Request {FileLU} a ->{FileRW, State FileSystemT, Error} a
fileLU result =
    match result with
        { link (src, dest) -> resume } ->
            let fs = get ()
                fs' = flink src dest fs
                put fs'
                handle resume () with fileLU
        { unlink name -> resume } ->
            let fs = get ()
                fs' = funlink name fs
                put fs'
                handle resume () with fileLU
        { result } -> result

fileIO m = handle (handle (handle !m with fileRW) with fileCO) with fileLU


{-
    pipes
    ======
-}

unique ability Await a
    where
        await: () -> a

unique ability Yield b
    where
        yield: b -> ()

pipe : ('{Yield b, e} a) -> ('{Await b, e} a) ->{e} a
pipe p c = handle c () with
                (cases
                    { x } -> x
                    { await () -> resume } -> copipe (resume) p)

copipe : (b -> {Await b, e} a) -> ('{Yield b, e} a) ->{e} a
copipe c p = handle p () with
                (cases
                    { x } -> x
                    { yield y -> resume } -> pipe resume '(c y) )

{-
    Process Syncronization
    ======================
-}

unique ability Co 
    where 
        ufork: Nat
        wait: Nat -> ()
        uinterrupt: ()
        nice: Nat -> Int
        renice: Nat -> Int -> ()

unique type Proc a e = Proc (Sstate a e ->{e} List (Nat, a))
unique type Pstate a e = Ready (Proc a e) | Blocked Nat (Proc a e)
unique type Sstate a e = {q: List (Nat, Pstate a e), done: List (Nat, a), pid: Nat, pnext: Nat}

runNext: Sstate a e ->{e} List (Nat, a)
runNext st =
    let (Sstate q done pid pnext) = st
        match q with
            [] -> done
            (pid', Blocked pid'' resume) +: q' -> 
                runNext (Sstate (q' lib.base.data.List.++ [(pid', Blocked pid'' resume)]) done pid pnext)
            (pid', Ready resume) +: q' -> 
                let st' = (Sstate q' done pid' pnext)
                    Proc (resume') = resume
                    resume' st'

modifyQueue: Nat -> [(Nat, Pstate a e)] -> [(Nat, Pstate a e)]
modifyQueue pid q =
    match q with
        [] -> []
        (pid', pstate) +: rest ->
            if pid == pid' then rest
            else (pid', pstate) +: modifyQueue pid rest

lookupNice: Nat -> [(Nat, Int)] -> Int
lookupNice pid prio =
    match prio with 
        [] -> -1 -- maybe warn here
        (pid', renice) +: rest ->
            if pid' == pid then
                renice 
            else 
                lookupNice pid rest 

modifyNice: Nat -> Int -> [(Nat, Int)] -> [(Nat, Int)]
modifyNice pid renice prio =
    match prio with
        [] -> [(pid, renice)]
        (pid', renice') +: rest ->
            if pid' == pid then
                (pid, renice) +: rest
            else 
                (pid', renice') +: modifyNice pid renice rest

lowestNiceInQueue: [(Nat, Int)] -> [(Nat, Pstate a e)] -> Either (Nat, Pstate a e) ()
lowestNiceInQueue niceValues q = 
    match q with 
        [] -> Right ()
        (pid, Blocked pid' resume) +: rest -> 
            lowestNiceInQueue niceValues rest
        (pid, Ready resume) +: rest ->
            let nextnice = lookupNice pid niceValues
                match lowestNiceInQueue niceValues rest with 
                    Left (pid', pstate) -> 
                        let nextnice' = lookupNice pid' niceValues
                            if nextnice < nextnice' then 
                                Left (pid, Ready resume)
                            else 
                                Left (pid', pstate)
                    Right () -> 
                        Left (pid, Ready resume)

runNextNice: Sstate a e -> [(Nat, Int)] ->{e} List (Nat, a)
runNextNice st niceValues = 
    let (Sstate q done pid pnext) = st
        match q with
            [] -> done
            (pid', Blocked pid'' resume) +: q' -> 
                runNextNice (Sstate (q' lib.base.data.List.++ [(pid', Blocked pid'' resume)]) done pid pnext) niceValues
            (pid', Ready resume) +: q' ->
                match lowestNiceInQueue niceValues q with
                    Left (pid', Ready resume) -> 
                        let st' = (Sstate q' done pid' pnext)
                            Proc (resume') = resume
                            resume' st'
                    Left (pid', Blocked pid'' resume) ->             -- unreachable
                        let st' = (Sstate q' done pid' pnext)
                            Proc (resume') = resume
                            resume' st'
                    Right () -> 
                        let st' = (Sstate q' done pid' pnext)
                            Proc (resume') = resume
                            resume' st'

minNice : Int
minNice = -20

schedAging: Sstate a e -> Request {Co, e} a ->{e, State [(Nat, Int)]} List (Nat, a)
schedAging st request = match request with
    {result} ->
        let (Sstate q done pid pnext) = st
            done' = done lib.base.data.List.++ [(pid, result)]
            runNextNice (Sstate q done' pid pnext) !get
    { ufork -> resume } ->
        let resume' = (Proc (st -> handle resume 0 with scheduler st))
            (Sstate q done pid pnext) = st
            nicevalue = lookupNice pid !get

            -- simple heuristic to avoid starvation, switch back to round robin if we reach min nice
            if nicevalue - +1 <= minNice then
                let q' = q lib.base.data.List.++ [(pid, Ready resume')]
                    pid' = pnext
                    pnext' = pnext + 1
                    handle resume pid' with scheduler (Sstate q' done pid pnext')
            else
                put (modifyNice pnext nicevalue !get)
                put (modifyNice pnext (nicevalue - +1) !get)

                pid' = pnext
                pnext' = pnext + 1

                q' = q lib.base.data.List.++ [(pid', Ready resume')]
                handle resume pid' with schedAging (Sstate q' done pid pnext)

    { nice pid -> resume } ->
        let (Sstate q done pid pnext) = st
            nicevalue = lookupNice pid !get
            handle resume nicevalue with schedAging st

    { renice pid newNice -> resume} -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            put (modifyNice pid newNice !get)
            runNextNice (Sstate q done pid pnext) !get
    
    { wait pid -> resume } ->
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = if processExists pid q then
                     q lib.base.data.List.++ [(pid, Blocked pid resume')]
                 else q lib.base.data.List.++ [(pid, Ready resume')]
            runNextNice (Sstate q' done pid pnext) !get
    { uinterrupt -> resume } ->
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = q lib.base.data.List.++ [(pid, Ready resume')]
            runNextNice (Sstate q' done pid pnext) !get

scheduler: Sstate a e -> Request {Co, e} a ->{e} List (Nat, a)
scheduler st request = match request with 
    { result } -> 
        let (Sstate q done pid pnext) = st 
            done' = done lib.base.data.List.++ [(pid, result)]
            runNext (Sstate q done' pid pnext)
    { ufork -> resume } -> 
        let resume' = (Proc (st -> handle resume 0 with scheduler st))
            (Sstate q done pid pnext) = st
            pid' = pnext
            pnext' = pnext + 1
            q' = q lib.base.data.List.++ [(pid', Ready resume')]
            handle resume pid' with scheduler (Sstate q' done pid pnext')
    { wait pid -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = if processExists pid q then
                     q lib.base.data.List.++ [(pid, Blocked pid resume')]
                 else q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)

    { nice pid -> resume } ->
        handle resume +0 with scheduler st

    {renice pid newNice -> resume} -> 
        handle resume () with scheduler st
        
    { uinterrupt -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)

processExists: Nat -> [(Nat, Pstate a e)] -> Boolean
processExists pid processes =
    match processes with
        [] -> false
        (pid', process) +: rest ->
            if pid == pid' then true
            else processExists pid rest

timeshare2 : '{g, Co} a ->{g} List (Nat, a)
timeshare2 m = handle !m with scheduler (Sstate [] [] 1 2)

init: '{e} a ->{e, Co} ()
init main = let pid = ufork
                if pid == 0 then
                    let a = main ()
                        ()
                else
                    wait pid

{-
    Permissions
    ============
-}

unique type Permission = Read | Write | AddUser | Grant | Revoke | Execute

all : [Permission]
all = [Read, Write, AddUser, Grant, Revoke, Execute]

unique ability Permit 
    where 
        grant: Text -> Permission -> ()
        revoke: Text -> Permission -> ()

checkPermission : User -> Permission -> [(Text, [Permission])] ->{e, Error, IO, Exception} ()
checkPermission user required perms =
    match perms with
        [] -> throw PermissionDenied
        (user', perms') +: rest ->
            if userToText user == user' then
                if allowed required perms' then
                    ()
                else
                    throw PermissionDenied
            else checkPermission user required rest

permissions: User -> Request {e, Permit, Session, FileRW, FileLU, FileCO, Co} a ->{e, Session, FileRW, FileLU, FileCO, Co, Error, State [(Text, [Permission])], IO, Exception} a
permissions user request = 
    match request with
        -- Permissions 
        {grant user' perm -> resume} -> 
            checkPermission user Grant !get
            existingPerms = lookupPermission user' !get 
            newPerms = perm +: existingPerms
            put (modifyPermission user' newPerms !get)
            handle resume () with permissions user
        
        {revoke user' perm -> resume} ->
            checkPermission user Revoke !get
            newPerms = removePermission perm (lookupPermission user' !get)
            put (modifyPermission user' newPerms !get)
            handle resume () with permissions user

        -- Users
        {ask var -> resume} -> 
            checkPermission user Read !get
            answer = ask var
            handle resume answer with permissions user 
        {su user' -> resume} -> 
            su user'
            handle resume () with permissions (Username user')
        {adduser user' -> resume} -> 
            checkPermission user AddUser !get
            adduser user'
            handle resume () with permissions user
        {setvar var val -> resume} -> 
            checkPermission user Write !get
            setvar var val
            handle resume () with permissions user

        -- Files
        {read i -> resume} -> 
            checkPermission user Read !get
            text = read i
            handle resume text with permissions user

        {write (i, text) -> resume} -> 
            checkPermission user Write !get
            write (i, text)
            handle resume () with permissions user
        
        {link (src, dest) -> resume} -> 
            checkPermission user Write !get
            link (src, dest)
            handle resume () with permissions user
        
        {unlink name -> resume} ->
            checkPermission user Write !get
            unlink name
            handle resume () with permissions user

        {create name -> resume} -> 
            checkPermission user Write !get
            ino = create name
            handle resume ino with permissions user

        {open name -> resume} ->
            checkPermission user Read !get
            ino = open name
            handle resume ino with permissions user

        {ufork -> resume} ->
            checkPermission user Execute !get
            let pid = ufork
                handle resume pid with permissions user

        {nice pid -> resume} ->
            checkPermission user Execute !get
            let nicevalue = nice pid
                handle resume nicevalue with permissions user

        {renice pid newnice -> resume} ->
            checkPermission user Execute !get
            renice pid newnice
            handle resume () with permissions user

        {wait pid -> resume} ->
            checkPermission user Execute !get
            wait pid
            handle resume () with permissions user

        {uinterrupt -> resume} ->
            checkPermission user Execute !get
            uinterrupt
            handle resume () with permissions user

        {result} -> result

lookupPermission: Text -> [(Text, [Permission])] -> [Permission]
lookupPermission var perms =
    match perms with
        [] -> []
        (var', perms') +: rest ->
            if var == var' then perms'
            else lookupPermission var rest

modifyPermission: Text -> [Permission] -> [(Text, [Permission])] -> [(Text, [Permission])]
modifyPermission var perms perms' =
    match perms' with
        [] -> [(var, perms)]
        (var', perms'') +: rest ->
            if var == var' then (var, perms) +: rest
            else (var', perms'') +: modifyPermission var perms rest

removePermission: Permission -> [Permission] -> [Permission]
removePermission perm perms =
    match perms with
        [] -> []
        perm' +: rest ->
            if permEquals perm perm' then rest
            else perm' +: removePermission perm rest

allowed: Permission -> [Permission] -> Boolean
allowed perm perms =
    match perms with
        [] -> false
        perm' +: rest ->
            if permEquals perm perm' then true
            else allowed perm rest

permEquals : Permission -> Permission -> Boolean
permEquals perms1 perms2 = 
    match perms1 with 
        Read -> 
            match perms2 with 
                Read -> true
                _ -> false
        Write -> 
            match perms2 with 
                Write -> true
                _ -> false
        AddUser -> 
            match perms2 with 
                AddUser -> true
                _ -> false
        Grant ->
            match perms2 with 
                Grant -> true
                _ -> false
        Revoke ->
            match perms2 with 
                Revoke -> true
                _ -> false
        Execute ->
            match perms2 with 
                Execute -> true
                _ -> false

initialPermissions : [(Text, [Permission])]
initialPermissions = [("root", all)]


{-
    Errors
-}

unique type EType = PermissionDenied | FileNotFound | FileExists | UserExists | NoSuchUser | UnknownError

toText: EType -> Text
toText = cases  
    PermissionDenied -> "Permission denied"
    FileNotFound -> "File not found"
    FileExists -> "File exists"
    UserExists -> "User exists"
    NoSuchUser -> "No such user"
    UnknownError -> "Unknown error"

unique ability Error
    where
        throw: EType -> ()

fail : Request {e, Error} a ->{e, IO, Exception, Status} Empty
fail request =
    match request with
        { throw err -> resume } -> 
            printLine (toText err)
            exit 1
        { result } -> exit 0

warn : Request {e, Error} a ->{e, IO, Exception} a
warn request =
    match request with
        { throw err -> resume } -> 
            printLine (toText err)
            handle resume () with warn
        { result } -> result

{-
    Retrofitting fork
-}

nondet2 : Request {TimeSharing} a -> [a]
nondet2 request =
    match request with
        { fork -> resume } -> 
            let pid = ufork
                handle resume (pid != 0) with nondet2
        { result } -> [result]

 {-
     Unix
    ======
-}

unix : '{e, BasicIO, FileRW, FileCO, FileLU, Error, Session, Permit, Co} a ->{e, IO, Exception} [(Nat, Nat)]
unix m = handle
            (handle 
                (handle
                    (handle
                        (handle
                        (handle
                            (handle 
                                (handle 
                                    (handle
                                        (handle 
                                            (handle
                                                (handle 
                                                    (handle
                                                        init m
                                                    with permissions (Username "root"))
                                                with runState initialPermissions)
                                            with env (Username "root")) 
                                        with runState initialUserspace)
                                    with fileCO)
                                with fileLU)
                        with fileRW)
                    with runState initialFileSystem)
                    with interruptWrite)
                with basicIO)
            with warn)
        with exitHandler)
    with scheduler (Sstate [] [] 1 2)

\end{lstlisting}

\chapter{Profiling Code}

The following code was used to profile the effect oriented and conventional
versions of the code. The code was run with the \texttt{timers} library
\cite{timers} and the results were recorded in section \ref{effop}.

\begin{lstlisting}[language=unison]
adduser': [User] -> User -> [User]
adduser' store user = 
    store :+ user

su' : [User] -> User -> [User]
su' store user = 
    match store with
        [] -> store
        (u +: rest) -> 
            let uname = userToText u
                username = userToText user
                if uname == username then 
                    u +: rest 
                else 
                    store

ask': [User] -> Text
ask' store = 
    match store with 
        [] -> ""
        (u +: rest) -> 
            let uname = userToText u
                uname

timings _ = 
    Timer.start "conventional"
    internal n env = 
        if n == 0 then 
            []
        else 
            let uname = Nat.toText (!randomNat)
                addeduser = adduser' [] (Username uname)
                newEnv = su' addeduser (Username uname)
                internal (n-1) newEnv
    Timer.stop "conventional"

report _ = printReport timings

timings' _ = 
    Timer.start "effectful"
    internal n = 
        if n == 0 then 
            ()
        else 
            let uname = Nat.toText (!randomNat)
                adduser uname 
                su uname
                internal (n-1)

    internal 1000
    Timer.stop "effectful"
    

timingsHandler' _ = handle (handle (handle !timings' with env (Username "root")) with runState initialUserspace) with warn

report' _ = printReport timingsHandler'
\end{lstlisting}

\bibliographystyle{unsrt}
\bibliography{diss}

\end{document}
