\documentclass[logo,bsc,singlespacing,parskip]{infthesis}

\usepackage{ugcheck}

\usepackage{microtype}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{subcaption}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{gray}{HTML}{666666}		%#666666
\definecolor{lightbule}{HTML}{006699}		%#006699
\definecolor{lightgreen}{HTML}{669900}		%#669900
\definecolor{bluegreen}{HTML}{33997e}		%#33997e
\definecolor{magenta}{HTML}{d94a7a}		%#d94a7a
\definecolor{orange}{HTML}{e2661a}		%#e2661a
\definecolor{purple}{HTML}{7d4793}		%#7d4793
\definecolor{green}{HTML}{718a62}		%#718a62

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=none,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstdefinelanguage{unison}{
  %keyword1&2&6
  morekeywords = [1]{ability, type, handle, with, if, then, else, match, cases, let},
  %keyword3
  morekeywords = [2]{unique, structural},
  %keyword4
  morekeywords = [3]{Status, BasicIO, User, Environment, Session, PState, Done, Paused, Interrupt, TimeSharing, Alice, Bob, Root, State, FileSystem, FileSystemT, FileRW, FileCO, FileLU, INode, INodeT, IList, IListT, DataRegion, DataRegionT, Directory, DirectoryT, Yield, Await},
  %keyword5
  morekeywords = [4]{Nat, Text, List, Tuple, (), Request, Boolean, IO, Exception},
  keywordstyle = [1]\color{bluegreen},
  keywordstyle = [2]\color{lightgreen},
  keywordstyle = [3]\color{codepurple},
  keywordstyle = [4]\color{orange},
  sensitive = true,
  morecomment = [l]{--},
  morecomment = [s]{\{-}{-\}},
  commentstyle = \color{gray},
  morestring = [b]",
  stringstyle = \color{purple}
}

\lstdefinestyle{terminal}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  captionpos=b,
  xleftmargin=10pt,
  numbers=none,
}

\lstset{style=mystyle}


\begin{document}
\begin{preliminary}

\title{Implementing UNIX with Effects Handlers}
\author{Ramsay Carslaw}

\course{Computer Science}
\project{4th Year Project Report}

\date{\today}

% https://okmij.org/ftp/continuations/ZFS/context-OS.pdf
% https://dl.acm.org/doi/pdf/10.1145/800087.802786

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}

\begin{acknowledgements}
  Any acknowledgements go here.
\end{acknowledgements}

\tableofcontents

\end{preliminary}

\chapter{Introduction}

\chapter{Background}

\section{Algebraic Effects and Effect Handlers}

Algebraic effects \cite{plotkin2002computational} and their corresponding
handlers \cite{plotkin2009handlers} \cite{pretnar2015introduction} are a
programming paradigm that when paired together offers a novel way to compose
programs. It starts with the definition of the effect or the \emph{effect
signature} that gives the effect a name in scope and specifies any input and the
return type otherwise known as the \emph{effect operation}.  For example, we
might define the effect signature \emph{State} that stores state for some type
\texttt{a}. In order to make use of our \emph{State} effect we can define the
effect operations \emph{put} and \emph{get} where put will update the value of
type \texttt{a} stored in state and get will return the current value.  At this
stage the effect operation has no implementation and is more an acknowledgement
to the compiler that it should expect an implementation. For this reason any
function that references these effect operations is known as an \emph{effectful
function} or a function whose definition is not complete without an effect
handler. In the put and get example, any function that uses put and get to store
values would be an effectful function. The \emph{effect handler} provides one
implementation of the given effect operation. We could define a simple handler
for state that simply updates a variable of the given type or we could define a
more complex one that uses hash maps.  In this way, we can change the semantics
of an effectful function by handling it with a different handler that provides
an alternative implementation to the effect. Crucially, we can have multiple
handlers defined in the same program for one effect allowing for much more
modular programming or \emph{effect-oreinted programming}.

When are programs rely on input from the real world like connecting to a server
on the internet or getting input from a user, it is no longer safe to assume
this input will be passed as we expect. For example, the server could time out
or not be at the address the program is expecting it to be at or the user could
enter a string that is too long for the input. These real world uncertainties
are known as \emph{Side Effects}. Effect handlers can be used to provide
alternate implementations of functions that may have side effects and allow for
control flow with these effects.

\subsection{Example in Unison}
\label{subsection:unison}

Unison \footnote{https://github.com/unisonweb/unison} is a
functional language implemented in Haskell that offers built in support for effect
handlers through it's abilities system.

Unison provides the \emph{ability} keyword which allows users to define their own
effects. It also provides the \emph{handle ... with ...} pattern to attach handlers to effectful functions.

\begin{lstlisting}[caption={The \emph{put} and \emph{store} example in Unison. Note that the \emph{structural} keyword refers to the fact that Unison stores type definitions as a hash. Even if we changed all the variable names it would still view it as the same type. To avoid that behaviour you can swap the \emph{structural} keyword for \emph{unique}}]
structural ability Store a where
  put: a -> {Store a} ()
  get: {Store a} a
\end{lstlisting}

This defines the two effect operations \texttt{put} and \texttt{get} that have
the effect signature \texttt{Store a}. Put takes a value of type \texttt{a} and
returns the unit type \texttt{()}. The prefix of \texttt{\{Store a\}} to the
\texttt{()}, refers to the fact that in order to allow for \texttt{put} to
return, it must be run from an effectful function that is handled with an
appropriate handler for \texttt{Store a}. Similarly, \texttt{put} takes an
argument of type \texttt{a} and must be handled.

\begin{lstlisting}[language=unison, caption={An example of an effectful function that uses the \texttt{Store} effect}]
addStore : a -> {Store a} ()
addStore x =
  y = get
  put (x + y)
\end{lstlisting}
\label{listing:addstore}

The code in listing \ref{listing:addstore} is an example of how you would use
the effects in Unison. It takes an argument of type \texttt{a} and `adds' it to
the current value by using \texttt{get}. Note that in order for this to work the
infix operation `+' must be implemented for type \texttt{a}. Now we only need to
define the handler.

\begin{lstlisting}[caption={The handler for the \texttt{Store} effect}]
    storeHandler : a -> Request (Store a) a -> a
    storeHandler value = cases
        {Store.get -> resume} -> handle resume value with storeHandler value
        {Store.put v -> resume} handle resume () with storeHandler v
        {result} -> result

\end{lstlisting}

The handlers in Unison use tail recursion to reduce to the case where just the
value is left \texttt{result -> result}. For both store and put we use the
resumption and the handler to reach the final value. The special type
\texttt{Request} allows us to perform pattern matching on the possible types of
the computation.

\begin{lstlisting}
handle (addStore 10) with storeHandler 10
\end{lstlisting}

Finally, we can put it all together by calling the function \texttt{addStore}
with the handler \texttt{storeHandler}. 

\section{Affine and `Multi-Shot' Handlers}

If remaining computation or continuation of an effect can be resumed once from
a handler then the effect system implements \emph{one-shot} or \emph{affine}
effect handlers. If it is able to resume the computation multiple times then it
is a \emph{multi-shot} handler. 

\section{The State of Effect-Oriented Programming}

\subsection{Library Based Effects}

\begin{itemize}
        \item{libhandler \cite{leijen2017implementing} is a portable c99 library
that implements algebraic effect handlers for C. It implements high performance
multi-shot effects using standard C functions. It is limited by the assumptions
it makes about the stack such as it being contiguous and not moving. In practice
this could lead to memory leaks if it copies pointers.}
        \item{libmprompt \footnote{https://github.com/koka-lang/libmprompt} is a
C/C++ library that adds effect handlers. It uses virtual memory to solve the
problem mentioned with libhandler. By keeping the stack in a fixed location in
virtual memory it restores safety. It also provides the higher level libmpeff
interface. A downside is they recommend at least 2GiB of virtual memory to
allow for 16000 stacks which may be challenging on some systems.}
        \item{cpp-effects \cite{DBLP:journals/pacmpl/GhicaLBP22} is a C++
implementation of effect handlers. It uses C++ template classes and types to
create modular effects and handlers. It's performance has been shown to be
comparable to C++20 coroutines. It's limitations are it only supports one-shot
        resumptions.}
        \item{There are several Haskell libraries that implement effect handlers
\cite{DBLP:conf/haskell/XieL20, DBLP:conf/haskell/KiselyovI15,
DBLP:conf/haskell/WuSH14}. Some are discussed in more detail below.}
        \begin{itemize}
          \item{EvEff uses lambda calculus based evidence translation to
implement it's effects system. It provides deep effects.}
          \item{fused-effects
\footnote{https://hackage.haskell.org/package/fused-effects} fuses the effect
handlers it provides with computation by applying \emph{fusion laws} that avoid
intermediate representation. The handlers in fused-effects are one-shot
however.}
        \end{itemize}
\end{itemize}

\subsection{First-Class Effects}

\begin{itemize}
        \item{Unison is shown in more detail in section \ref{subsection:unison}}
        \item{Koka \cite{DBLP:journals/corr/Leijen14} is a statically typed
functional language with effect types and handlers. It can also compile
straight to C code without needing a garbage collector. Koka is developed by a
small team and as such is still missing much of its standard library.}
        \item{Frank \cite{DBLP:conf/popl/LindleyMM17} is a strict functional
language that is \emph{effectful} in that it has first class support for
bi-directional effects and effect handlers. }
        \item{Links \cite{DBLP:conf/fmco/CooperLWY06} is a functional
programming language designed for the web. Out of the box it does not support
true algebraic effects, however through an extension
\cite{DBLP:conf/icfp/HillerstromL16} it gains first class support for
continuations.}
\end{itemize}

\section{Shallow vs. Deep Effect Handlers}

There are two types of effect handler implementation, \emph{deep handlers}, as
originally defined by Plotkin and Pretnar \cite{plotkin2009handlers} and
\emph{shallow handlers} \cite{hillerstrom2018shallow}. Deep handlers pass a
copy of the full handler along with the computation which allows for the
handler to be invoked again as the handlers receive themselves as an argument.
Shallow handlers do not pass the handler with the computation. There are also
\emph{sheep handlers}, which while being shallow implement some of the
behaviour of deep handlers leading to the name sheep or shallow + deep. In
practice, the type of handler is more of an implementation detail although it
can have an effect on how code is structured.

\section{\textsc{UNIX}}

\textsc{Unix} \cite{ritchie1978unix} is an operating system designed and
implemented by Dennis M. Ritchie and Ken Thompson at AT\&T's Bell Labs in 1974.
It provides a file system (directories, file protection etc.), a shell,
processes (pipe, fork etc) and a userspace. Since it's first release it has been
reimplemented for a variety of systems.

\subsection{The UNIX Philosophy}

A phrase often associated with \textsc{Unix} is the \emph{Unix philosophy}.  The
\textsc{Unix} philosophy refers to some of the core principles with which it was
developed. The core principles involve composing many small simple programs that
accomplish one task well to solve more complex tasks \cite{raymond2003art}. The
idea of many small modular components has spread to many areas of computer
science including effect oriented programming.

\section{Effect Based File Systems}

Continuations in operating systems \cite{DBLP:conf/context/KiselyovS07}.

\section{Effect Handlers and UNIX}

In chapter 2 of his 2022 thesis, Daniel Hillerstr\"{o}m
\cite{hillerstrom2022foundations} outlines a theoretical implementation of UNIX
using the effects syntax outlined by Kammar et. al. \cite{kammar2013handlers}.
In this he provides an implementation of the original \textsc{Unix} paper
\cite{ritchie1978unix} that includes a filesystem and timesharing.
Hillerstr\"{o}m makes several assumptions about the effect system that would
need to be taken into account in order to implement this with a real language.
The main assumption is multi-shot handlers. For example the implementation of
\texttt{fork} uses multi-shot handlers to copy the full stack on both branches.
There are also some partial implementations such as \texttt{sed} \footnote{It is
worth mentioning \texttt{sed} has $20,000+$ lines of code} from which he only
implements string replacement.

\chapter{Base Implementation}

\section{Effect Oriented Programming in Unison}

As is shown in section \ref{subsection:unison}, effect oriented programming in
Unison is composed of an effect definition with an effect signature and a set
of effect operations and any handlers for that effect signature.

\section{Program Status}
\label{status}

In \texttt{Unix} programs must provide a code when they exit (usually 0 for
success and anything else for failure). The effect signature \texttt{Status}
provides the \texttt{exit} operation which takes one argument of type
\texttt{Nat} \footnote{a positive integer in Unison} and returns the empty type
which is defined \texttt{unique type Empty =}. The argument represents the
return code.

\begin{lstlisting}[language=unison]
unique ability Status
       where
            exit: Nat -> Empty
\end{lstlisting}

We can now use this to indicate program status. For example:

\begin{lstlisting}[language=unison]
  --- some functionality 

  if somethingWentWrong == true then
    exit 1
  else
    print "Hello, World"
\end{lstlisting}

There is no explicit exit 0 on the else branch. This is because the default
state of a program should be 0, it should not need an explicit \texttt{exit 0}.

\subsection{Unique vs. Structural Types}

In Unison, \texttt{unique} types are used when the name of the type is
semantically important. The alternative is \texttt{structural} types which are
used when the name of the type is not important and it can be stored as a hash
without it's name. \texttt{unique} types are used for all effects as it has no
real implication given the program is not distributed.

\subsection{The Handler}

The handler for \texttt{Status} is defined as:

\begin{lstlisting}[language=unison]
exitHandler : Request {e, Status} x -> Nat
exitHandler request =
    match request with
          { result } -> 0
          { exit v -> resume } -> abort
\end{lstlisting}

The implementation for exit has no effect it simply consumes the exit code and
returns. The handler however returns a \texttt{Nat} return code. If an exit
operation is encountered we return the value given to the exit operation. The
return case simply returns 0 as if we reach the end of a function being handled
by the handler then we can assume it was successful and return 0.


\subsection{The Request Type}

The \texttt{Request} type is a special type in Unison that allows for pattern
matching on operations of an effect. In the braces are the effect types for the
handler. The \texttt{Status} is the effect signature that is explicitly being
handled. The \texttt{e} allows for any other effects in the computation to be
passed through. The \texttt{x} is the return type of the computation.

\section{Basic I/O}
\label{io}

The \emph{effect signature} \texttt{BasicIO} is used for simple I/O operations.
The first and only \emph{effect operation} of \texttt{BasicIO} is \texttt{echo}
which takes an argument of type \texttt{Text} and returns the unit
type \texttt{()}. 

\begin{lstlisting}[language=unison]
unique ability BasicIO where
  echo: Text -> ()
\end{lstlisting}

The handler for \texttt{BasicIO} is simply a wrapper for Unison's
\texttt{putText} function which it uses to print the given text to
\texttt{stdout}. It then handles the resumption with the same handler to handle
any further \texttt{echo} calls.

\begin{lstlisting}[language=unison]
basicIO : Request {BasicIO} x ->{IO, Exception} ()
basicIO result =
    match result with
        { echo text -> resume } -> 
          putText stdOut text; 
          handle resume () with basicIO
        { result } -> ()
\end{lstlisting}

\subsection{IO and Exception abilities}

The handler for \texttt{BasicIO} uses the \texttt{putText} function from
Unison's standard library because of this we must include the \texttt{\{IO,
Exeption\}} in the type signature to indicate that this function needs access
to both the \texttt{IO} and \texttt{Exception} abilities in order to be run.
Both of these abilities are built in and used for all input and output in
unison.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]

\section*{Program 1 --- Hello World}
\label{prog:helloworld}

By combining the operations of Status and BasicIO we can write a simple program that prints ``Hello, World!" and then exits with the successful error code. Notice that the operations are invoked in the same way as functions. In this case they are being used inside a function. It would be possible to implement a simple shell for these commands however that is outside the scope of this project.

\begin{lstlisting}[language=unison]
greetAndExit : a ->{BasicIO, Status} ()
greetAndExit _ = echo "Hello, World!\n"; exit 0
\end{lstlisting}

By composing the two handlers in sections \ref{status} and \ref{io} we can run the program.

\begin{lstlisting}[language=unison]
runGreetAndExit _ = handle (handle !greetAndExit with basicIO) with exitHandler
\end{lstlisting}

By running this function with the unison codebase manager we get

\begin{lstlisting}[style=terminal]
Hello, World!

  0
\end{lstlisting}
\end{tcolorbox}

\subsection{Defining Multiple Handlers}

Effects are not limited to just one handler. The semantics of echo can be
changed without altering it's definition. For example, the \texttt{backwardsIO}
handler below.

\begin{lstlisting}[language=unison]
backwardsIO : Request {BasicIO} x ->{IO, Exception} () 
backwardsIO result =
  match result with
  { echo text -> resume } -> 
    handle resume () with basicIO 
    putText stdOut text;
  { result } -> ()
\end{lstlisting}

In this case, the resumption is handled first and then the text is printed. The
effect of this is best shown by running it side by side with \texttt{basicIO}
on the following program.

\begin{lstlisting}[language=unison]
helloworld _ = echo "Hello,"; echo " World!\\n"
\end{lstlisting}

The output of running this program with each handler is shown in Figure \ref{fig:sidebyside}.

\begin{figure}[h]
  \label{fig:sidebyside}
\begin{minipage}{0.5\textwidth}

\begin{lstlisting}[style=terminal]
> handle !helloworld with basicIO

Hello, World!

  ()
\end{lstlisting}

\end{minipage}%
\begin{minipage}{0.5\textwidth}

\begin{lstlisting}[style=terminal]
 > handle !helloworld with backwardsIO

 World!
Hello,
  ()
\end{lstlisting}
\end{minipage}
\caption{The output of running \texttt{helloworld} with each handler.}
\end{figure}

\section{A Unix Function}

When we start composing handlers like in Program \hyperref[prog:helloworld]{1}
the \texttt{handle (handle (...) with ... ) with ...)} syntax can start to get
verbose. To solve this we will introduce one \textsc{Unix} function where we
compose all the handlers that takes a function using the operations we have
defined as an argument.

\begin{lstlisting}[language=unison]
unix : (() ->{e, BasicIO, Status} a) ->{e, IO, Exception} Nat
unix prog = handle (handle !prog with basicIO) with exitHandler
\end{lstlisting}

We accept a function as an argument that needs both \texttt{Status} and
\texttt{BasicIO} to be handled in order to be run. We then apply the handlers
to the function and run it. We handle status last as this gives us \texttt{Nat}
as a return code which the whole function can return. We can now run
\texttt{unix helloworld} to get the following:

\begin{lstlisting}[language=unison]
  Hello, World!

    0
\end{lstlisting}

We now get the 0 return code as the result of the computation, indicating it was successful.

\section{Users and Environment}

To introduce the concept of a user-space and users we can start by adding some
hard coded users. For now, alice, bob and a root user: \texttt{unique type User
= Alice | Bob | Root}.

Next we introduce the \texttt{Session} signature for operations involving
users. The operation \texttt{su} or \emph{substitute user} is used to change
the environment to that of a different user. The \texttt{ask} operation can be
used to access environment variables. Since the only variable we have now is
\texttt{USER} the argument to ask is a unit.

\begin{lstlisting}[language=unison]
unique ability Session
    where
        su: User -> {Session } ()
        ask: () -> {Session } Text
\end{lstlisting}

We can now implement the \textsc{Unix} command \texttt{whoami} with a wrapper
around ask.

\begin{lstlisting}[language=unison]
whoami: '{Session} Text
whoami _ = ask ()
\end{lstlisting}

We now have all the tools to keep track of which user is logged in and display
that information:

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 2 --- Session Management}
  
  We can now compose the handlers we have written so far to switch between the
  users and invoke \texttt{whoami}.

  \begin{lstlisting}[language=unison]
    session _ = su Alice
                echo (!whoami)
                echo "\n"
                su Bob
                echo (!whoami)
                echo "\n"
                su Root
                echo(!whoami)
                echo "\n"
  \end{lstlisting}

  The function \texttt{runsession} simply invokes \texttt{session} using our
  \texttt{unix} function.

  \begin{lstlisting}[language=unison]
    runsession _ = unix session
  \end{lstlisting}

  \begin{lstlisting}[style=terminal]
    alice
    bob
    root
      
      0
\end{lstlisting}
\end{tcolorbox}

\subsection{The Apostrophe in Unison}

The \texttt{'} character in Unison is syntactic sugar for a function with a
unit as the type of it's first argument. For example, the type signature of 
\texttt{whoami} could be rewritten as \texttt{() ->\{Session\} Text}. This is 
equivalent to \texttt{'\{Session\} Text}.

\subsection{Environment as a handler}

The handler for \texttt{Session} also takes a user as an argument, this is the
user that is currently logged in. To switch user we simply handle the rest of
the computation with the new user provided as the argument to \texttt{su}. Then
when the computation ends we will be back in the environment of the old user.

Due to the single environment variable being \texttt{USER}, \texttt{ask}
performs the action of \texttt{whoami}. It keeps the user the same and returns
the user as a string.

\begin{lstlisting}[language=unison]
env: User -> Request {Session} a -> a
env user request = 
    match request with
        {result} -> result
        { ask () -> resume } -> match user with 
            Alice -> handle resume "alice" with env user
            Bob -> handle resume "bob" with env user
            Root -> handle resume "root" with env user
        {su user' -> resume} -> handle resume () with env user'
\end{lstlisting}

In this way the environment is the handler itself as it contains the
information such as which user is logged in. The handler can be extended to
have parameterised environment variables making it the complete environment.

\subsection{Adding the Handler to the Unix Function}

Given the \texttt{unix} function represents the initial state of the system we
choose the root user to be logged in by passing it as an argument to the
handler as well as composing it with the other two.

\begin{lstlisting}[language=unison]
unix : '{e, Session, BasicIO, Status} a ->{e, IO, Exception} Nat
unix prog = handle (handle (handle !prog with basicIO) with env Root) with exitHandler
\end{lstlisting}

We still leave the \texttt{exitHandler} on the outside to get the return code.

\section{Nondeterminism}

To implement the \texttt{fork} command from \textsc{Unix} we can leverage
deliberate non-determinism that is possible with effect handlers. We define the
\texttt{fork} operation which returns a \texttt{Boolean} as a member of the
\texttt{TimeSharing} signature.

\begin{lstlisting}[language=unison]
unique ability TimeSharing
    where
        fork: Boolean
\end{lstlisting}

To use \texttt{fork} we can simply use it in control flow to create a branch.
Where normally only one branch would be executed, the two branches become our
two processes. For example:

\begin{lstlisting}[language=unison]
if fork then 
  echo "Heads\n"
else 
  echo "Tails\n"
\end{lstlisting}

By running that code with the \texttt{unix} function we get:

\begin{lstlisting}[style=terminal]
  Heads
  Tails
    
    0
\end{lstlisting}

The handler for fork is also fairly simple:

\begin{lstlisting}[language=unison]
nondet : Request {TimeSharing} a -> [a]
nondet request =
    match request with
        { fork -> resume } -> (handle resume true with nondet) lib.base.data.List.++ (handle resume false with nondet)
        { result } -> [result]
\end{lstlisting}

The handler returns a list of values with the type \texttt{a} which is the
return type of the computation. When we encounter a \texttt{fork} we resume
with the values true and false and join the two lists that are created. The
return case wraps the value in a list so that we can use the \texttt{++}
operator.

\subsection{Joining Lists in Unison}

Unison's typechecker sometimes struggles inferring the type of \texttt{++}. For
this reason we include the full path to the standard library where \texttt{++}
is defined i.e. \texttt{lib.base.data.List.++}.

\section{Scheduling}

Now that we can create processes through \texttt{fork} it would be useful to be able to write scheduling algorithms. Currently \texttt{fork} will run the first process to completion, and then run the second process to completion. To begin scheduling we need to give the processes a method of stopping execution and giving control to the other process. We introduce the \texttt{Interrupt} signature with one operation also called \texttt{interrupt}.

\begin{lstlisting}[language=unison]
unique ability Interrupt
    where
        interrupt: {Interrupt } ()
\end{lstlisting}

Now that we have \texttt{interrupt} we can write an alternative handler for
\texttt{BasicIO} that will \texttt{interrupt} before every IO operation,
allowing for the other process to run first.

\begin{lstlisting}[language=unison]
interruptWrite : Request {e, BasicIO} x ->{e, Interrupt, BasicIO} ()
interruptWrite result =
    match result with
        { echo text -> resume } -> 
            interrupt
            echo text 
            handle resume () with interruptWrite
        { result } -> ()
\end{lstlisting}

Note that we still need to provide a handler for \texttt{echo}, this handler
simply injects interrupt in front of every instance of \texttt{echo}.

In order to schedule processes we need to introduce state. Each process can either be \texttt{Done} (It has produced a return value) or \texttt{Paused} (It has been interrupted). \texttt{Paused} is a recursive definition as it contains a \texttt{PState} in it's type.

\begin{lstlisting}[language=unison]
unique type PState a e = Done a | Paused ('{e} PState a e)
\end{lstlisting}

The type \texttt{a} is the return type of the process and the \texttt{e} is an
effect variable that represents any effects that are needed to run the
\texttt{PState}. This can be thought of as analagous to the \emph{resumption
monad} first introduced by Milner in 1975 \cite{MILNER1975157}, in that
computation is split into either the result or another computation i.e. the
resumption. We can now implement the handler for \texttt{interrupt}.

\begin{lstlisting}[language=unison]
reifyProcess : Request {Interrupt, e} a -> PState a e
reifyProcess request =
    match request with
        { interrupt -> resume } -> Paused (_ -> handle !resume with reifyProcess )
        { result } -> Done result
\end{lstlisting}

In the case of an interrupt, the handler suspends the computation by making it
an anonymous function with a unit type as it's first argument, and wrapping it
in the paused datatype. This means we can run the \texttt{Paused} computations
later by invoking that function we created. The return case simply wraps the
value in the \texttt{Done} type. 

\begin{lstlisting}[language=unison]
sched : [PState a {e, TimeSharing}] -> [a] ->{e} [a]
sched ps done = 
    match ps with
        [] -> done
        (Done res) +: ps' -> sched ps' (res lib.base.data.List.+: done)
        (Paused m) +: ps' -> sched (ps' lib.base.data.List.++ (handle !m with nondet)) done

timeshare : '{g, Interrupt, TimeSharing} o ->{g} [o]
timeshare m = sched [Paused (_ -> handle !m with reifyProcess)] []
\end{lstlisting}

\section{Serial File System}
\label{sec:filesystem}

\subsection{State}

To implement a file system we need to introduce a method of storing and
retrieving state. The effect signature and operations introduced in section
\ref{subsection:unison} provide the perfect interface as it takes a generic
type \texttt{a} as an argument, we can introduce our own type to represent the
filesystem and use it as an argument to \texttt{State}.

\subsection{Definitions}

\textbf{File System} ---
Unlike a real \textsc{Unix} implementation we only implement the most basic
operations on files, i.e. creation, deletion, reading and writing. Additionally
we treat everything as a file, unlike \textsc{Unix} which has directories and
special files, we only allow basic files. Thus the file tree is completely flat.

\textbf{Serial} --- Each file can only be read from in order, additionally when
we write to file, there are no write modes, we only append to the file.
Semantically, different write modes can be achieved with the four basic
operations and can be implemented by composing handlers. For example,
overwriting a file is equivalent to deleting the existing file, creating a new
one with the same name and writing the content to the new file.

\subsection{Types}
\label{sec:filesystemtypes}

\begin{lstlisting}[language=unison]
unique type DirectoryT = Directory (Text, Nat)
unique type DataRegionT = DataRegion (Nat, Text)
unique type INodeT = INode Nat Nat
unique type IListT = IList (Nat, INodeT)
unique type FileSystemT = FileSystem (List DirectoryT) (List IListT) (List DataRegionT) Nat Nat
\end{lstlisting}

\begin{itemize}
  \item{\texttt{DirectoryT} --- A directory stores a file name with it's associated I-number}
  \item{\texttt{INode} --- An I-Node stores the metadata for a file along with a pointer to a \texttt{DataRegion}}
  \item{\texttt{IList} --- An I-List stores an I-number with an I-Node}
  \item{\texttt{DataRegion} --- A DataRegion contains the actual file contents along with the pointer from the \texttt{INode}}
\end{itemize}

Finally, the \texttt{FileSystem} type collects the above types into lists along with two \texttt{Nat}'s to represent the next directory number and the next I-number.

\subsection{Initial File System}

Much like \texttt{Root} is the initial user, we introduce an initial file
system by initialising the types in section \ref{sec:filesystemtypes}. We
create the file \texttt{stdout} to represent the standard output file at
I-number 0.

\begin{lstlisting}[language=unison]
initialINode : INodeT
initialINode = INode 0 0

initialDirectory : DirectoryT
initialDirectory = (Directory ("stdout", 0))


initialDataRegion : DataRegionT
initialDataRegion = DataRegion (0, "")

initialIList : IListT
initialIList = IList (0, initialINode)

initialFileSystem : FileSystemT
initialFileSystem = FileSystem [initialDirectory] [initialIList] [initialDataRegion] 0 0
\end{lstlisting}

\subsection{Effect Types and Operations}

Now we have the types and the state we can introduce the new effect signatures
and operations. Firstly, \texttt{FileRW} which provides the \texttt{read} and
\texttt{write}.

\begin{lstlisting}[language=unison]
unique ability FileRW
  where
      read: Nat -> Text
      write: (Nat, Text) -> ()
\end{lstlisting}

\textbf{read} --- Read takes an I-number and returns the text at the corresponding data region.

\textbf{write} -- Write takes an I-number and some text and appends the text to
the end of the data region pointed to by the I-number.

Next \texttt{FileCO} which is used for creating and opening files.
\begin{lstlisting}[language=unison]
unique ability FileCO
  where
      create: Text -> Nat
      open: Text -> Nat
\end{lstlisting}
\texttt{FileCO} provides two operations, \texttt{create} and \texttt{open}.

\textbf{create} --- Create takes a filename and returns a fresh I-number for
the new file. If the provided filename exists it will overwrite the file to be
blank again.

\textbf{open} --- Open takes a filename and returns the I-number associated with it.

Finally, we have \texttt{FileLU} which links and unlinks files.

\begin{lstlisting}[language=unison]
unique ability FileLU
    where
        link: (Text, Text) -> ()
        unlink: Text -> ()
\end{lstlisting}


\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 3 -- \texttt{mv}}

  We can now use these effect operations to define a \texttt{mv} command. While
  it can be used to move files between directories we have a flat file system
  so in this case it's more of a rename command.

  \begin{lstlisting}[language=unison]

mv : Text -> Text ->{State FileSystemT, FileRW, FileCO} ()
mv src dest = 
    let file = read (open src)
        _ = create src
        write ((create dest), file)

  \end{lstlisting}

  First we use open to obtain the I-number of of the \texttt{INode} of the
  source file, we can then use this I-number as an argument to \texttt{read} to
  obtain the contents of the source file. Now that the contents of the source
  file are stored in the \texttt{file} varaible, we can safely delete the
  source file by calling \texttt{create} on it. If \texttt{create} is called on
  an existing file it will delete that file by overwriting it. Since we no
  longer need it's I-number we assign the return value of the \texttt{create}
  to an empty variable. Finally, in one step we create the destination file
  (overwriting it if it exists) and write the value of the variable
  \texttt{file} to this new file using the I-number returned from
  \texttt{create}.

\end{tcolorbox}

\section{Pipes}

In \textsc{Unix}, a pipe is essentially syntactic sugar for connecting the input
and output of two files. Given the simple nature of the file-system described
in section \ref{sec:filesystem}, and the lack of true \texttt{stdout} and
\texttt{stdin} files, pipes are represented as effect operations that are
connected via handlers.

\texttt{Yield} and \texttt{Await} are two new effect signatures for
implementing pipes. \texttt{Yield} performs some computation and returns or
`yields' a value, \texttt{Await} takes that value as an argument and then
performs computation. Using the \texttt{yield} operation can be thought of as
writing to \texttt{stdout} and \texttt{await} is reading from \texttt{stdin}.

\begin{lstlisting}[language=unison]
unique ability Await a
    where
        await: () -> {Await } a

unique ability Yield a
    where
        yield: a -> {Yield } ()
\end{lstlisting}

\subsection{Cat}
In \textsc{Unix}, \texttt{cat} prints the contents of a file to
\texttt{stdout}. In this case, pipes can be used, by yielding the file a
character at a time other utilities can simply await input.  

\begin{lstlisting}[language=unison]
-- TODO check this works 
cat: Text -> {FileRW, FileCO, Yield Text, e} -> ()
cat fname = 
  let ino = open fname
      iter (ch -> yield ch) (read ino)
      yield '\0'

\end{lstlisting}

\subsection{Grep}

The \texttt{Unix} utility grep is used for searching for strings within a body
of text. At it's most simple  form it returns true if it finds an instance of
the target string in the source. Grep is often used as a consumer of a pipe
which is why it will be implemented using await.

\begin{lstlisting}[language=unison]
-- TODO check this works
grep: Text ->{Await Text} Boolean 
grep target = 
  grepRec target buffer n length =
    if n < length then
      grepRec target (buffer ++ !await) n+1 length
    else 
      if buffer == target then
        True
      else 
        if buffer == "" then
          False
        else 
          grepRec target ((drop 1 buffer) ++ !await) n length
  grepRec target "" 0 (length target)

\end{lstlisting}

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 4 -- Searching in a set of files}
  
  Given a list of filenames we want to return the name of each file that
  contains a particular string. We can compose \texttt{cat} and \texttt{grep}
  to achieve this.

  \begin{lstlisting}[language=unison]
  
  searchFiles: Text -> [Text] ->{FileRW, FileCO, Await Text, Yield Text, e} [Text]
  searchFiles target fnames = match fnames with 
    [] -> []
    fname +: rest -> 
      if pipe (cat fname) (grep target) then
        fname ++ searchFiles target rest
      else
        searchFiles target rest

  \end{lstlisting}
\end{tcolorbox}

\subsection{Pipe and Copipe Handler}

The handlers can now be defined:

\begin{lstlisting}[language=unison]
pipe : ('{Yield b, e} a) -> ('{Await b, e} a) ->{e} a
pipe p c = handle c () with
                (cases
                    { x } -> x
                    { await () -> resume } -> copipe (resume) p)

copipe : (b -> {Await b, e} a) -> ('{Yield b, e} a) ->{e} a
copipe c p = handle p () with
                (cases
                    { x } -> x
                    { yield y -> resume } -> pipe resume '(c y) )
\end{lstlisting}

Each handler takes two arguments: a producer, \texttt{p} and a consumer,
\texttt{c}. Both arguments are suspended computations that produce a value of
type \texttt{a}. A producer may invoke \texttt{Yield} and a consumer may invoke
\texttt{Await}.

The \texttt{pipe} handler immediately handles the consumer and defines an
inline function to handle it with. If the consumer invokes an await it is
handled with the \texttt{copipe} with the producer and the resumption of the
consumer. This means that the consumer process is blocked until the producer
can produce it's value.

Similarly, the \texttt{copipe} handler runs the producer until it yields a
value, that value is then given to the suspended consumer and given back to the
pipe handler.

\section{Unix Fork}

\subsection{Process ID's}

It would be useful to be able to keep track of multiple processes.
\textsc{Unix} uses process ID's or \texttt{pid}'s for this purpose. Whenever a
program forks, fork should return a process ID of the newly created process. 
This then allows programs to `wait' for a particular process to finish.

\subsection{Effect Signature}

The updated effect signature now includes \texttt{wait} which will wait for a
process with the specified \texttt{pid}. Fork now returns the \texttt{pid} of
the newly created process. The type of interrupt remains unchanged. Fork and
interrupt are renamed to \texttt{ufork} and \texttt{uinterrupt} to avoid having
to overwrite the previous definition.

\begin{lstlisting}[language=unison]
unique ability Co 
    where 
        ufork: Nat
        wait: Nat -> ()
        uinterrupt: ()
\end{lstlisting}

\subsection{Types}

Now that the program must also handle \texttt{pid}'s there must be more state
that is capable of storing this information. \texttt{Done} and \texttt{Paused}
become \texttt{Ready} and \texttt{Blocked} as now, a process is either ready to
run, or blocked by another process. Instead of returning just a return value of
\texttt{a} it must now also return which process returned that value, hence the
\texttt{List (Nat, a)} type.

\begin{lstlisting}[language=unison]
unique type Proc a e = Proc (Sstate a e ->{e} List (Nat, a))
unique type Pstate a e = Ready (Proc a e) | Blocked Nat (Proc a e)
unique type Sstate a e = {q: List (Nat, Pstate a e), done: List (Nat, a), pid: Nat, pnext: Nat}
\end{lstlisting}

Finally, there is the \texttt{Sstate} type which has the queue of process to be
run, the list of process that are finished or done and the current and next
process ID's.

\begin{tcolorbox}[colback=gray!10, colframe=black, arc=0pt, outer arc=0pt]
  \section*{Program 5 -- Init process}

  When \textsc{Unix} is initialised it forks to create a new process to run all
  programs on. The original process is then the parent process of every process
  created by the operating system.

  \begin{lstlisting}[language=unison]
init: '{e} a ->{e, Co} ()
init main = let pid = ufork
                if pid == 0 then
                    let a = main ()
                        ()
                else
                    wait pid
  \end{lstlisting}

  We accept one argument \texttt{main} which is the function to be ran as the
  first program. If we are on the ancestor process ($pid = 0$) then we capture
  the return value of main while running it and return the unit type. If we are
  on any other process we wait for the main process.
\end{tcolorbox}

\subsection{Running a process}

The \texttt{runNext} function takes an argument of type \texttt{Sstate} and
runs it to produce the list of pid's and return values.

\begin{lstlisting}[language=unison]
runNext: Sstate a e ->{e} List (Nat, a)
runNext st =
    let (Sstate q done pid pnext) = st
        match q with
            [] -> done
            (pid', Blocked pid'' resume) +: q' -> 
                runNext (Sstate (q' lib.base.data.List.++ [(pid', Blocked pid'' resume)]) done pid pnext)
            (pid', Ready resume) +: q' -> 
                let st' = (Sstate q' done pid' pnext)
                    Proc (resume') = resume
                    resume' st'
\end{lstlisting}

It unpacks the \texttt{Sstate} and matches on the queue. When it encounters a
blocked process, it sends it to the back of the queue and recursively calls the
function on the new queue. When it encounters a process that is ready to be run
it unpacks the \texttt{Proc} type and gives the \texttt{Sstate} as an argument
to the resumption, thus creating the list.

\subsection{The handler}

\begin{lstlisting}[language=unison]
scheduler: Sstate a e -> Request {Co, e} a ->{e} List (Nat, a)
scheduler st request = match request with 
    { result } -> 
        let (Sstate q done pid pnext) = st 
            done' = done lib.base.data.List.++ [(pid, result)]
            runNext (Sstate q done' pid pnext)
    { ufork -> resume } -> 
        let resume' = (Proc (st -> handle resume 0 with scheduler st))
            (Sstate q done pid pnext) = st
            pid' = pnext
            pnext' = pnext + 1
            q' = q lib.base.data.List.++ [(pid', Ready resume')]
            handle resume pid' with scheduler (Sstate q' done pid pnext')
    { wait pid -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = if processExists pid q then
                     q lib.base.data.List.++ [(pid, Blocked pid resume')]
                 else q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)
    { uinterrupt -> resume } -> 
        let resume' = (Proc (st -> handle resume () with scheduler st))
            (Sstate q done pid pnext) = st
            q' = q lib.base.data.List.++ [(pid, Ready resume')]
            runNext (Sstate q' done pid pnext)
\end{lstlisting}

\chapter{Extensions}

\section{Error Handling}

Currently, whenever this implementation encounters an error or problem it will
silently fail. To address this we will introduce different types of error
through the \texttt{EType} type.

\begin{lstlisting}[language=unison]
unique type EType = PermissionDenied | FileNotFound | FileExists | UserExists | UnknownError
\end{lstlisting}

We provide common errors that might occur in \textsc{Unix} as well as a
catch-all unknown error. Now is also a good time to provide a \texttt{toText}
implementation for \texttt{EType} such that we can print them later. This is 
simply pattern matching on each possible value of \texttt{EType} and returning a sensible string for the error message:

\begin{lstlisting}[language=unison]
toText: EType -> Text
toText = cases  
    PermissionDenied -> "Permission denied"
    FileNotFound -> "File not found"
    FileExists -> "File exists"
    UserExists -> "User exists"
    UnknownError -> "Unknown error"
\end{lstlisting}

Now we can introduce the \texttt{Error} signature which provides only one
operation \texttt{throw}. Throw takes an argument of type \texttt{EType} and
returns the unit.

\begin{lstlisting}[language=unison]
unique ability Error
    where
        throw: EType -> ()

fail : Request {e, Error} a ->{e, IO, Exception, Status} Empty
fail request =
    match request with
        { throw err -> resume } -> 
            printLine (toText err)
            exit 1
        { result } -> exit 0

warn : Request {e, Error} a ->{e, IO, Exception} a
warn request =
    match request with
        { throw err -> resume } -> 
            printLine (toText err)
            handle resume () with warn
        { result } -> result
\end{lstlisting}

\section{Environment Variables}

\begin{lstlisting}[language=unison]
unique type User = Alice | Bob | Root

unique ability Session
    where
        su: User -> ()
        ask: Text -> Text
        export: Text -> Text -> ()

whoami: '{Session} Text
whoami _ = ask "USER"

env: User -> Request {Session} a ->{State [(User, [(Text, Text)])]} a
env user request = 
    match request with
        {result} -> result

        { ask var -> resume } -> 
            match var with 
                "USER" ->
                    match user with 
                        Alice -> handle resume "alice" with env user
                        Bob -> handle resume "bob" with env user
                        Root -> handle resume "root" with env user
                var -> 
                    let st = get ()
                        envs = lookupEnvs user st
                        val = lookupEnvVar var envs
                        handle resume val with env user

        {su user' -> resume} -> 
            handle resume () with env user'

        {export var val -> resume} -> 
            let st = get ()
                envs = lookupEnvs user st
                envs' = modifyEnvVar var val envs
                put (modifyEnvs user envs' st) 
                handle resume () with env user

lookupEnvVar: Text -> [(Text, Text)] -> Text
lookupEnvVar var env =
    match env with
        [] -> ""
        (var', val) +: rest ->
            if var == var' then val
            else lookupEnvVar var rest

modifyEnvVar: Text -> Text -> [(Text, Text)] -> [(Text, Text)]
modifyEnvVar var val env =
    match env with
        [] -> [(var, val)]
        (var', val') +: rest ->
            if var == var' then (var, val) +: rest
            else (var', val') +: modifyEnvVar var val rest

lookupEnvs: User -> [(User, [(Text, Text)])] -> [(Text, Text)]
lookupEnvs user envs =
    match envs with
        [] -> []
        (user', env) +: rest ->
            if userEquals user user' then env
            else lookupEnvs user rest

modifyEnvs: User -> [(Text, Text)] -> [(User, [(Text, Text)])] -> [(User, [(Text, Text)])]
modifyEnvs user env envs =
    match envs with
        [] -> [(user, env)]
        (user', env') +: rest ->
            if userEquals user user' then (user, env) +: rest
            else (user', env') +: modifyEnvs user env rest

userEquals: User -> User -> Boolean
userEquals user user' =
    match user with
        Alice -> 
            match user' with 
                Alice -> true
                _ -> false
        Bob -> 
            match user' with 
                Bob -> true
                _ -> false
        Root -> 
            match user' with 
                Root -> true
                _ -> false
\end{lstlisting}

\section{Generic Users}

\begin{lstlisting}[language=unison]
unique type User = Username Text

unique ability Session
    where
        su: Text -> ()
        ask: Text -> Text
        export: Text -> Text -> ()
        adduser: Text -> ()

whoami: '{Session} Text
whoami _ = ask "USER"

env: User -> Request {Session} a ->{State [(User, [(Text, Text)])]} a
env user request = 
    match request with
        {result} -> result

        { ask var -> resume } -> 
           let st = get ()
               envs = lookupEnvs user st
               val = lookupEnvVar var envs
               handle resume val with env user

        {su user' -> resume} -> 
            if userExists (Username user') (get ()) then
                handle resume () with env (Username user')
            else 
                handle resume () with env user   -- fail

        {export var val -> resume} -> 
            let st = get ()
                envs = lookupEnvs user st
                envs' = modifyEnvVar var val envs
                put (modifyEnvs user envs' st) 
                handle resume () with env user

        {adduser user' -> resume} ->
            if userToText user == "root" then
                let st = get ()
                    newuser = (Username user')
                    newvars = [("USER", user')]
                    newenv = modifyEnvs newuser newvars st
                    if (userExists newuser st) then
                        put newenv
                        handle resume () with env newuser
                    else 
                        handle resume () with env user
            else 
                handle resume () with env user   -- fail

lookupEnvVar: Text -> [(Text, Text)] -> Text
lookupEnvVar var env =
    match env with
        [] -> ""
        (var', val) +: rest ->
            if var == var' then val
            else lookupEnvVar var rest

modifyEnvVar: Text -> Text -> [(Text, Text)] -> [(Text, Text)]
modifyEnvVar var val env =
    match env with
        [] -> [(var, val)]
        (var', val') +: rest ->
            if var == var' then (var, val) +: rest
            else (var', val') +: modifyEnvVar var val rest

lookupEnvs: User -> [(User, [(Text, Text)])] -> [(Text, Text)]
lookupEnvs user envs =
    match envs with
        [] -> []
        (user', env) +: rest ->
            if userToText user == userToText user' then env
            else lookupEnvs user rest

modifyEnvs: User -> [(Text, Text)] -> [(User, [(Text, Text)])] -> [(User, [(Text, Text)])]
modifyEnvs user env envs =
    match envs with
        [] -> [(user, env)]
        (user', env') +: rest ->
            if userToText user == userToText user' then (user, env) +: rest
            else (user', env') +: modifyEnvs user env rest

userExists: User -> [(User, [(Text, Text)])] -> Boolean
userExists user envs =
    match envs with
        [] -> false
        (user', env) +: rest ->
            if userToText user == userToText user' then true
            else userExists user rest

userToText: User -> Text
userToText user = 
    let (Username username) = user
        username

initialUserspace : [(User, [(Text, Text)])]
initialUserspace = [(Username "root", [("USER", "root")] )]
\end{lstlisting}

\section{Permissions}

\begin{lstlisting}[language=unison]
unique type Permission = Read | Write | AddUser | Grant | Revoke | Execute

all : [Permission]
all = [Read, Write, AddUser, Grant, Revoke, Execute]

unique ability Permit 
    where 
        grant: Text -> Permission -> ()
        revoke: Text -> Permission -> ()

checkPermission : User -> Permission -> [(Text, [Permission])] ->{e, Error, IO, Exception} ()
checkPermission user required perms =
    match perms with
        [] -> throw PermissionDenied
        (user', perms') +: rest ->
            if userToText user == user' then
                if allowed required perms' then
                    ()
                else
                    throw PermissionDenied
            else checkPermission user required rest

permissions: User -> Request {e, Permit, Session, FileRW, FileLU, FileCO, Co} a ->{e, Session, FileRW, FileLU, FileCO, Co, Error, State [(Text, [Permission])], IO, Exception} a
permissions user request = 
    match request with
        -- Permissions 
        {grant user' perm -> resume} -> 
            checkPermission user Grant !get
            existingPerms = lookupPermission user' !get 
            newPerms = perm +: existingPerms
            put (modifyPermission user' newPerms !get)
            handle resume () with permissions user
        
        {revoke user' perm -> resume} ->
            checkPermission user Revoke !get
            newPerms = removePermission perm (lookupPermission user' !get)
            put (modifyPermission user' newPerms !get)
            handle resume () with permissions user

        -- Users
        {ask var -> resume} -> 
            checkPermission user Read !get
            answer = ask var
            handle resume answer with permissions user 
        {su user' -> resume} -> 
            su user'
            handle resume () with permissions (Username user')
        {adduser user' -> resume} -> 
            checkPermission user AddUser !get
            adduser user'
            handle resume () with permissions user
        {export var val -> resume} -> 
            checkPermission user Write !get
            export var val
            handle resume () with permissions user

        -- Files
        {read i -> resume} -> 
            checkPermission user Read !get
            text = read i
            handle resume text with permissions user

        {write (i, text) -> resume} -> 
            checkPermission user Write !get
            write (i, text)
            handle resume () with permissions user
        
        {link (src, dest) -> resume} -> 
            checkPermission user Write !get
            link (src, dest)
            handle resume () with permissions user
        
        {unlink name -> resume} ->
            checkPermission user Write !get
            unlink name
            handle resume () with permissions user

        {create name -> resume} -> 
            checkPermission user Write !get
            ino = create name
            handle resume ino with permissions user

        {open name -> resume} ->
            checkPermission user Read !get
            ino = open name
            handle resume ino with permissions user

        {ufork -> resume} ->
            checkPermission user Execute !get
            let pid = ufork
                handle resume pid with permissions user

        {wait pid -> resume} ->
            checkPermission user Execute !get
            wait pid
            handle resume () with permissions user

        {uinterrupt -> resume} ->
            checkPermission user Execute !get
            uinterrupt
            handle resume () with permissions user

        {result} -> result

lookupPermission: Text -> [(Text, [Permission])] -> [Permission]
lookupPermission var perms =
    match perms with
        [] -> []
        (var', perms') +: rest ->
            if var == var' then perms'
            else lookupPermission var rest

modifyPermission: Text -> [Permission] -> [(Text, [Permission])] -> [(Text, [Permission])]
modifyPermission var perms perms' =
    match perms' with
        [] -> [(var, perms)]
        (var', perms'') +: rest ->
            if var == var' then (var, perms) +: rest
            else (var', perms'') +: modifyPermission var perms rest

removePermission: Permission -> [Permission] -> [Permission]
removePermission perm perms =
    match perms with
        [] -> []
        perm' +: rest ->
            if permEquals perm perm' then rest
            else perm' +: removePermission perm rest

allowed: Permission -> [Permission] -> Boolean
allowed perm perms =
    match perms with
        [] -> false
        perm' +: rest ->
            if permEquals perm perm' then true
            else allowed perm rest

permEquals : Permission -> Permission -> Boolean
permEquals perms1 perms2 = 
    match perms1 with 
        Read -> 
            match perms2 with 
                Read -> true
                _ -> false
        Write -> 
            match perms2 with 
                Write -> true
                _ -> false
        AddUser -> 
            match perms2 with 
                AddUser -> true
                _ -> false
        Grant ->
            match perms2 with 
                Grant -> true
                _ -> false
        Revoke ->
            match perms2 with 
                Revoke -> true
                _ -> false
        Execute ->
            match perms2 with 
                Execute -> true
                _ -> false

initialPermissions : [(Text, [Permission])]
initialPermissions = [("root", all)]
\end{lstlisting}

\chapter{Evaluation}

\chapter{Conclusion}

\bibliographystyle{unsrt}
\bibliography{diss}

\end{document}
